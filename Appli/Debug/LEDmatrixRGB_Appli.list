
LEDmatrixRGB_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000002b0  70000000  70000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002b7c  700002b0  700002b0  000012b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000020  70002e2c  70002e2c  00003e2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  70002e4c  70002e4c  00004030  2**0
                  CONTENTS
  4 .ARM          00000008  70002e4c  70002e4c  00003e4c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  70002e54  70002e54  00004030  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  70002e54  70002e54  00003e54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  70002e58  70002e58  00003e58  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000030  24000000  70002e5c  00004000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000018d0  24000030  70002e8c  00004030  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000000  20000000  00001000  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  00004030  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000d339  00000000  00000000  0000405e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00001b18  00000000  00000000  00011397  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000009c8  00000000  00000000  00012eb0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 0000077b  00000000  00000000  00013878  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00030246  00000000  00000000  00013ff3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0000d07d  00000000  00000000  00044239  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00132076  00000000  00000000  000512b6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  0018332c  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000027f4  00000000  00000000  00183370  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000061  00000000  00000000  00185b64  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

700002b0 <__do_global_dtors_aux>:
700002b0:	b510      	push	{r4, lr}
700002b2:	4c05      	ldr	r4, [pc, #20]	@ (700002c8 <__do_global_dtors_aux+0x18>)
700002b4:	7823      	ldrb	r3, [r4, #0]
700002b6:	b933      	cbnz	r3, 700002c6 <__do_global_dtors_aux+0x16>
700002b8:	4b04      	ldr	r3, [pc, #16]	@ (700002cc <__do_global_dtors_aux+0x1c>)
700002ba:	b113      	cbz	r3, 700002c2 <__do_global_dtors_aux+0x12>
700002bc:	4804      	ldr	r0, [pc, #16]	@ (700002d0 <__do_global_dtors_aux+0x20>)
700002be:	f3af 8000 	nop.w
700002c2:	2301      	movs	r3, #1
700002c4:	7023      	strb	r3, [r4, #0]
700002c6:	bd10      	pop	{r4, pc}
700002c8:	24000030 	.word	0x24000030
700002cc:	00000000 	.word	0x00000000
700002d0:	70002e14 	.word	0x70002e14

700002d4 <frame_dummy>:
700002d4:	b508      	push	{r3, lr}
700002d6:	4b03      	ldr	r3, [pc, #12]	@ (700002e4 <frame_dummy+0x10>)
700002d8:	b11b      	cbz	r3, 700002e2 <frame_dummy+0xe>
700002da:	4903      	ldr	r1, [pc, #12]	@ (700002e8 <frame_dummy+0x14>)
700002dc:	4803      	ldr	r0, [pc, #12]	@ (700002ec <frame_dummy+0x18>)
700002de:	f3af 8000 	nop.w
700002e2:	bd08      	pop	{r3, pc}
700002e4:	00000000 	.word	0x00000000
700002e8:	24000034 	.word	0x24000034
700002ec:	70002e14 	.word	0x70002e14

700002f0 <__aeabi_uldivmod>:
700002f0:	b953      	cbnz	r3, 70000308 <__aeabi_uldivmod+0x18>
700002f2:	b94a      	cbnz	r2, 70000308 <__aeabi_uldivmod+0x18>
700002f4:	2900      	cmp	r1, #0
700002f6:	bf08      	it	eq
700002f8:	2800      	cmpeq	r0, #0
700002fa:	bf1c      	itt	ne
700002fc:	f04f 31ff 	movne.w	r1, #4294967295
70000300:	f04f 30ff 	movne.w	r0, #4294967295
70000304:	f000 b96a 	b.w	700005dc <__aeabi_idiv0>
70000308:	f1ad 0c08 	sub.w	ip, sp, #8
7000030c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
70000310:	f000 f806 	bl	70000320 <__udivmoddi4>
70000314:	f8dd e004 	ldr.w	lr, [sp, #4]
70000318:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
7000031c:	b004      	add	sp, #16
7000031e:	4770      	bx	lr

70000320 <__udivmoddi4>:
70000320:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
70000324:	9d08      	ldr	r5, [sp, #32]
70000326:	460c      	mov	r4, r1
70000328:	2b00      	cmp	r3, #0
7000032a:	d14e      	bne.n	700003ca <__udivmoddi4+0xaa>
7000032c:	4694      	mov	ip, r2
7000032e:	458c      	cmp	ip, r1
70000330:	4686      	mov	lr, r0
70000332:	fab2 f282 	clz	r2, r2
70000336:	d962      	bls.n	700003fe <__udivmoddi4+0xde>
70000338:	b14a      	cbz	r2, 7000034e <__udivmoddi4+0x2e>
7000033a:	f1c2 0320 	rsb	r3, r2, #32
7000033e:	4091      	lsls	r1, r2
70000340:	fa20 f303 	lsr.w	r3, r0, r3
70000344:	fa0c fc02 	lsl.w	ip, ip, r2
70000348:	4319      	orrs	r1, r3
7000034a:	fa00 fe02 	lsl.w	lr, r0, r2
7000034e:	ea4f 471c 	mov.w	r7, ip, lsr #16
70000352:	fa1f f68c 	uxth.w	r6, ip
70000356:	fbb1 f4f7 	udiv	r4, r1, r7
7000035a:	ea4f 431e 	mov.w	r3, lr, lsr #16
7000035e:	fb07 1114 	mls	r1, r7, r4, r1
70000362:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
70000366:	fb04 f106 	mul.w	r1, r4, r6
7000036a:	4299      	cmp	r1, r3
7000036c:	d90a      	bls.n	70000384 <__udivmoddi4+0x64>
7000036e:	eb1c 0303 	adds.w	r3, ip, r3
70000372:	f104 30ff 	add.w	r0, r4, #4294967295
70000376:	f080 8112 	bcs.w	7000059e <__udivmoddi4+0x27e>
7000037a:	4299      	cmp	r1, r3
7000037c:	f240 810f 	bls.w	7000059e <__udivmoddi4+0x27e>
70000380:	3c02      	subs	r4, #2
70000382:	4463      	add	r3, ip
70000384:	1a59      	subs	r1, r3, r1
70000386:	fa1f f38e 	uxth.w	r3, lr
7000038a:	fbb1 f0f7 	udiv	r0, r1, r7
7000038e:	fb07 1110 	mls	r1, r7, r0, r1
70000392:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
70000396:	fb00 f606 	mul.w	r6, r0, r6
7000039a:	429e      	cmp	r6, r3
7000039c:	d90a      	bls.n	700003b4 <__udivmoddi4+0x94>
7000039e:	eb1c 0303 	adds.w	r3, ip, r3
700003a2:	f100 31ff 	add.w	r1, r0, #4294967295
700003a6:	f080 80fc 	bcs.w	700005a2 <__udivmoddi4+0x282>
700003aa:	429e      	cmp	r6, r3
700003ac:	f240 80f9 	bls.w	700005a2 <__udivmoddi4+0x282>
700003b0:	4463      	add	r3, ip
700003b2:	3802      	subs	r0, #2
700003b4:	1b9b      	subs	r3, r3, r6
700003b6:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
700003ba:	2100      	movs	r1, #0
700003bc:	b11d      	cbz	r5, 700003c6 <__udivmoddi4+0xa6>
700003be:	40d3      	lsrs	r3, r2
700003c0:	2200      	movs	r2, #0
700003c2:	e9c5 3200 	strd	r3, r2, [r5]
700003c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
700003ca:	428b      	cmp	r3, r1
700003cc:	d905      	bls.n	700003da <__udivmoddi4+0xba>
700003ce:	b10d      	cbz	r5, 700003d4 <__udivmoddi4+0xb4>
700003d0:	e9c5 0100 	strd	r0, r1, [r5]
700003d4:	2100      	movs	r1, #0
700003d6:	4608      	mov	r0, r1
700003d8:	e7f5      	b.n	700003c6 <__udivmoddi4+0xa6>
700003da:	fab3 f183 	clz	r1, r3
700003de:	2900      	cmp	r1, #0
700003e0:	d146      	bne.n	70000470 <__udivmoddi4+0x150>
700003e2:	42a3      	cmp	r3, r4
700003e4:	d302      	bcc.n	700003ec <__udivmoddi4+0xcc>
700003e6:	4290      	cmp	r0, r2
700003e8:	f0c0 80f0 	bcc.w	700005cc <__udivmoddi4+0x2ac>
700003ec:	1a86      	subs	r6, r0, r2
700003ee:	eb64 0303 	sbc.w	r3, r4, r3
700003f2:	2001      	movs	r0, #1
700003f4:	2d00      	cmp	r5, #0
700003f6:	d0e6      	beq.n	700003c6 <__udivmoddi4+0xa6>
700003f8:	e9c5 6300 	strd	r6, r3, [r5]
700003fc:	e7e3      	b.n	700003c6 <__udivmoddi4+0xa6>
700003fe:	2a00      	cmp	r2, #0
70000400:	f040 8090 	bne.w	70000524 <__udivmoddi4+0x204>
70000404:	eba1 040c 	sub.w	r4, r1, ip
70000408:	ea4f 481c 	mov.w	r8, ip, lsr #16
7000040c:	fa1f f78c 	uxth.w	r7, ip
70000410:	2101      	movs	r1, #1
70000412:	fbb4 f6f8 	udiv	r6, r4, r8
70000416:	ea4f 431e 	mov.w	r3, lr, lsr #16
7000041a:	fb08 4416 	mls	r4, r8, r6, r4
7000041e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
70000422:	fb07 f006 	mul.w	r0, r7, r6
70000426:	4298      	cmp	r0, r3
70000428:	d908      	bls.n	7000043c <__udivmoddi4+0x11c>
7000042a:	eb1c 0303 	adds.w	r3, ip, r3
7000042e:	f106 34ff 	add.w	r4, r6, #4294967295
70000432:	d202      	bcs.n	7000043a <__udivmoddi4+0x11a>
70000434:	4298      	cmp	r0, r3
70000436:	f200 80cd 	bhi.w	700005d4 <__udivmoddi4+0x2b4>
7000043a:	4626      	mov	r6, r4
7000043c:	1a1c      	subs	r4, r3, r0
7000043e:	fa1f f38e 	uxth.w	r3, lr
70000442:	fbb4 f0f8 	udiv	r0, r4, r8
70000446:	fb08 4410 	mls	r4, r8, r0, r4
7000044a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
7000044e:	fb00 f707 	mul.w	r7, r0, r7
70000452:	429f      	cmp	r7, r3
70000454:	d908      	bls.n	70000468 <__udivmoddi4+0x148>
70000456:	eb1c 0303 	adds.w	r3, ip, r3
7000045a:	f100 34ff 	add.w	r4, r0, #4294967295
7000045e:	d202      	bcs.n	70000466 <__udivmoddi4+0x146>
70000460:	429f      	cmp	r7, r3
70000462:	f200 80b0 	bhi.w	700005c6 <__udivmoddi4+0x2a6>
70000466:	4620      	mov	r0, r4
70000468:	1bdb      	subs	r3, r3, r7
7000046a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
7000046e:	e7a5      	b.n	700003bc <__udivmoddi4+0x9c>
70000470:	f1c1 0620 	rsb	r6, r1, #32
70000474:	408b      	lsls	r3, r1
70000476:	fa22 f706 	lsr.w	r7, r2, r6
7000047a:	431f      	orrs	r7, r3
7000047c:	fa20 fc06 	lsr.w	ip, r0, r6
70000480:	fa04 f301 	lsl.w	r3, r4, r1
70000484:	ea43 030c 	orr.w	r3, r3, ip
70000488:	40f4      	lsrs	r4, r6
7000048a:	fa00 f801 	lsl.w	r8, r0, r1
7000048e:	0c38      	lsrs	r0, r7, #16
70000490:	ea4f 4913 	mov.w	r9, r3, lsr #16
70000494:	fbb4 fef0 	udiv	lr, r4, r0
70000498:	fa1f fc87 	uxth.w	ip, r7
7000049c:	fb00 441e 	mls	r4, r0, lr, r4
700004a0:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
700004a4:	fb0e f90c 	mul.w	r9, lr, ip
700004a8:	45a1      	cmp	r9, r4
700004aa:	fa02 f201 	lsl.w	r2, r2, r1
700004ae:	d90a      	bls.n	700004c6 <__udivmoddi4+0x1a6>
700004b0:	193c      	adds	r4, r7, r4
700004b2:	f10e 3aff 	add.w	sl, lr, #4294967295
700004b6:	f080 8084 	bcs.w	700005c2 <__udivmoddi4+0x2a2>
700004ba:	45a1      	cmp	r9, r4
700004bc:	f240 8081 	bls.w	700005c2 <__udivmoddi4+0x2a2>
700004c0:	f1ae 0e02 	sub.w	lr, lr, #2
700004c4:	443c      	add	r4, r7
700004c6:	eba4 0409 	sub.w	r4, r4, r9
700004ca:	fa1f f983 	uxth.w	r9, r3
700004ce:	fbb4 f3f0 	udiv	r3, r4, r0
700004d2:	fb00 4413 	mls	r4, r0, r3, r4
700004d6:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
700004da:	fb03 fc0c 	mul.w	ip, r3, ip
700004de:	45a4      	cmp	ip, r4
700004e0:	d907      	bls.n	700004f2 <__udivmoddi4+0x1d2>
700004e2:	193c      	adds	r4, r7, r4
700004e4:	f103 30ff 	add.w	r0, r3, #4294967295
700004e8:	d267      	bcs.n	700005ba <__udivmoddi4+0x29a>
700004ea:	45a4      	cmp	ip, r4
700004ec:	d965      	bls.n	700005ba <__udivmoddi4+0x29a>
700004ee:	3b02      	subs	r3, #2
700004f0:	443c      	add	r4, r7
700004f2:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
700004f6:	fba0 9302 	umull	r9, r3, r0, r2
700004fa:	eba4 040c 	sub.w	r4, r4, ip
700004fe:	429c      	cmp	r4, r3
70000500:	46ce      	mov	lr, r9
70000502:	469c      	mov	ip, r3
70000504:	d351      	bcc.n	700005aa <__udivmoddi4+0x28a>
70000506:	d04e      	beq.n	700005a6 <__udivmoddi4+0x286>
70000508:	b155      	cbz	r5, 70000520 <__udivmoddi4+0x200>
7000050a:	ebb8 030e 	subs.w	r3, r8, lr
7000050e:	eb64 040c 	sbc.w	r4, r4, ip
70000512:	fa04 f606 	lsl.w	r6, r4, r6
70000516:	40cb      	lsrs	r3, r1
70000518:	431e      	orrs	r6, r3
7000051a:	40cc      	lsrs	r4, r1
7000051c:	e9c5 6400 	strd	r6, r4, [r5]
70000520:	2100      	movs	r1, #0
70000522:	e750      	b.n	700003c6 <__udivmoddi4+0xa6>
70000524:	f1c2 0320 	rsb	r3, r2, #32
70000528:	fa20 f103 	lsr.w	r1, r0, r3
7000052c:	fa0c fc02 	lsl.w	ip, ip, r2
70000530:	fa24 f303 	lsr.w	r3, r4, r3
70000534:	4094      	lsls	r4, r2
70000536:	430c      	orrs	r4, r1
70000538:	ea4f 481c 	mov.w	r8, ip, lsr #16
7000053c:	fa00 fe02 	lsl.w	lr, r0, r2
70000540:	fa1f f78c 	uxth.w	r7, ip
70000544:	fbb3 f0f8 	udiv	r0, r3, r8
70000548:	fb08 3110 	mls	r1, r8, r0, r3
7000054c:	0c23      	lsrs	r3, r4, #16
7000054e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
70000552:	fb00 f107 	mul.w	r1, r0, r7
70000556:	4299      	cmp	r1, r3
70000558:	d908      	bls.n	7000056c <__udivmoddi4+0x24c>
7000055a:	eb1c 0303 	adds.w	r3, ip, r3
7000055e:	f100 36ff 	add.w	r6, r0, #4294967295
70000562:	d22c      	bcs.n	700005be <__udivmoddi4+0x29e>
70000564:	4299      	cmp	r1, r3
70000566:	d92a      	bls.n	700005be <__udivmoddi4+0x29e>
70000568:	3802      	subs	r0, #2
7000056a:	4463      	add	r3, ip
7000056c:	1a5b      	subs	r3, r3, r1
7000056e:	b2a4      	uxth	r4, r4
70000570:	fbb3 f1f8 	udiv	r1, r3, r8
70000574:	fb08 3311 	mls	r3, r8, r1, r3
70000578:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
7000057c:	fb01 f307 	mul.w	r3, r1, r7
70000580:	42a3      	cmp	r3, r4
70000582:	d908      	bls.n	70000596 <__udivmoddi4+0x276>
70000584:	eb1c 0404 	adds.w	r4, ip, r4
70000588:	f101 36ff 	add.w	r6, r1, #4294967295
7000058c:	d213      	bcs.n	700005b6 <__udivmoddi4+0x296>
7000058e:	42a3      	cmp	r3, r4
70000590:	d911      	bls.n	700005b6 <__udivmoddi4+0x296>
70000592:	3902      	subs	r1, #2
70000594:	4464      	add	r4, ip
70000596:	1ae4      	subs	r4, r4, r3
70000598:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
7000059c:	e739      	b.n	70000412 <__udivmoddi4+0xf2>
7000059e:	4604      	mov	r4, r0
700005a0:	e6f0      	b.n	70000384 <__udivmoddi4+0x64>
700005a2:	4608      	mov	r0, r1
700005a4:	e706      	b.n	700003b4 <__udivmoddi4+0x94>
700005a6:	45c8      	cmp	r8, r9
700005a8:	d2ae      	bcs.n	70000508 <__udivmoddi4+0x1e8>
700005aa:	ebb9 0e02 	subs.w	lr, r9, r2
700005ae:	eb63 0c07 	sbc.w	ip, r3, r7
700005b2:	3801      	subs	r0, #1
700005b4:	e7a8      	b.n	70000508 <__udivmoddi4+0x1e8>
700005b6:	4631      	mov	r1, r6
700005b8:	e7ed      	b.n	70000596 <__udivmoddi4+0x276>
700005ba:	4603      	mov	r3, r0
700005bc:	e799      	b.n	700004f2 <__udivmoddi4+0x1d2>
700005be:	4630      	mov	r0, r6
700005c0:	e7d4      	b.n	7000056c <__udivmoddi4+0x24c>
700005c2:	46d6      	mov	lr, sl
700005c4:	e77f      	b.n	700004c6 <__udivmoddi4+0x1a6>
700005c6:	4463      	add	r3, ip
700005c8:	3802      	subs	r0, #2
700005ca:	e74d      	b.n	70000468 <__udivmoddi4+0x148>
700005cc:	4606      	mov	r6, r0
700005ce:	4623      	mov	r3, r4
700005d0:	4608      	mov	r0, r1
700005d2:	e70f      	b.n	700003f4 <__udivmoddi4+0xd4>
700005d4:	3e02      	subs	r6, #2
700005d6:	4463      	add	r3, ip
700005d8:	e730      	b.n	7000043c <__udivmoddi4+0x11c>
700005da:	bf00      	nop

700005dc <__aeabi_idiv0>:
700005dc:	4770      	bx	lr
700005de:	bf00      	nop

700005e0 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
700005e0:	b580      	push	{r7, lr}
700005e2:	b08a      	sub	sp, #40	@ 0x28
700005e4:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
700005e6:	f107 0314 	add.w	r3, r7, #20
700005ea:	2200      	movs	r2, #0
700005ec:	601a      	str	r2, [r3, #0]
700005ee:	605a      	str	r2, [r3, #4]
700005f0:	609a      	str	r2, [r3, #8]
700005f2:	60da      	str	r2, [r3, #12]
700005f4:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
700005f6:	4b46      	ldr	r3, [pc, #280]	@ (70000710 <MX_GPIO_Init+0x130>)
700005f8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700005fc:	4a44      	ldr	r2, [pc, #272]	@ (70000710 <MX_GPIO_Init+0x130>)
700005fe:	f043 0320 	orr.w	r3, r3, #32
70000602:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000606:	4b42      	ldr	r3, [pc, #264]	@ (70000710 <MX_GPIO_Init+0x130>)
70000608:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000060c:	613b      	str	r3, [r7, #16]
7000060e:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
70000610:	4b3f      	ldr	r3, [pc, #252]	@ (70000710 <MX_GPIO_Init+0x130>)
70000612:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000616:	4a3e      	ldr	r2, [pc, #248]	@ (70000710 <MX_GPIO_Init+0x130>)
70000618:	f043 0302 	orr.w	r3, r3, #2
7000061c:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000620:	4b3b      	ldr	r3, [pc, #236]	@ (70000710 <MX_GPIO_Init+0x130>)
70000622:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000626:	60fb      	str	r3, [r7, #12]
70000628:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
7000062a:	4b39      	ldr	r3, [pc, #228]	@ (70000710 <MX_GPIO_Init+0x130>)
7000062c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000630:	4a37      	ldr	r2, [pc, #220]	@ (70000710 <MX_GPIO_Init+0x130>)
70000632:	f043 0310 	orr.w	r3, r3, #16
70000636:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
7000063a:	4b35      	ldr	r3, [pc, #212]	@ (70000710 <MX_GPIO_Init+0x130>)
7000063c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000640:	60bb      	str	r3, [r7, #8]
70000642:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
70000644:	4b32      	ldr	r3, [pc, #200]	@ (70000710 <MX_GPIO_Init+0x130>)
70000646:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000064a:	4a31      	ldr	r2, [pc, #196]	@ (70000710 <MX_GPIO_Init+0x130>)
7000064c:	f043 0301 	orr.w	r3, r3, #1
70000650:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000654:	4b2e      	ldr	r3, [pc, #184]	@ (70000710 <MX_GPIO_Init+0x130>)
70000656:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000065a:	607b      	str	r3, [r7, #4]
7000065c:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOF, C_Pin|CLK_Pin|A_Pin, GPIO_PIN_RESET);
7000065e:	2200      	movs	r2, #0
70000660:	f248 0118 	movw	r1, #32792	@ 0x8018
70000664:	482b      	ldr	r0, [pc, #172]	@ (70000714 <MX_GPIO_Init+0x134>)
70000666:	f001 fa55 	bl	70001b14 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, OE_Pin|LAT_Pin|B2_Pin, GPIO_PIN_RESET);
7000066a:	2200      	movs	r2, #0
7000066c:	f44f 4186 	mov.w	r1, #17152	@ 0x4300
70000670:	4829      	ldr	r0, [pc, #164]	@ (70000718 <MX_GPIO_Init+0x138>)
70000672:	f001 fa4f 	bl	70001b14 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, B_Pin|D_Pin|R1_Pin|B1_Pin
70000676:	2200      	movs	r2, #0
70000678:	f44f 5176 	mov.w	r1, #15744	@ 0x3d80
7000067c:	4827      	ldr	r0, [pc, #156]	@ (7000071c <MX_GPIO_Init+0x13c>)
7000067e:	f001 fa49 	bl	70001b14 <HAL_GPIO_WritePin>
                          |R2_Pin|G1_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(G2_GPIO_Port, G2_Pin, GPIO_PIN_RESET);
70000682:	2200      	movs	r2, #0
70000684:	f44f 6180 	mov.w	r1, #1024	@ 0x400
70000688:	4825      	ldr	r0, [pc, #148]	@ (70000720 <MX_GPIO_Init+0x140>)
7000068a:	f001 fa43 	bl	70001b14 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PFPin PFPin PFPin */
  GPIO_InitStruct.Pin = C_Pin|CLK_Pin|A_Pin;
7000068e:	f248 0318 	movw	r3, #32792	@ 0x8018
70000692:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
70000694:	2301      	movs	r3, #1
70000696:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
70000698:	2300      	movs	r3, #0
7000069a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
7000069c:	2302      	movs	r3, #2
7000069e:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
700006a0:	f107 0314 	add.w	r3, r7, #20
700006a4:	4619      	mov	r1, r3
700006a6:	481b      	ldr	r0, [pc, #108]	@ (70000714 <MX_GPIO_Init+0x134>)
700006a8:	f001 f8de 	bl	70001868 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = OE_Pin|LAT_Pin|B2_Pin;
700006ac:	f44f 4386 	mov.w	r3, #17152	@ 0x4300
700006b0:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
700006b2:	2301      	movs	r3, #1
700006b4:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
700006b6:	2300      	movs	r3, #0
700006b8:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
700006ba:	2302      	movs	r3, #2
700006bc:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
700006be:	f107 0314 	add.w	r3, r7, #20
700006c2:	4619      	mov	r1, r3
700006c4:	4814      	ldr	r0, [pc, #80]	@ (70000718 <MX_GPIO_Init+0x138>)
700006c6:	f001 f8cf 	bl	70001868 <HAL_GPIO_Init>

  /*Configure GPIO pins : PEPin PEPin PEPin PEPin
                           PEPin PEPin */
  GPIO_InitStruct.Pin = B_Pin|D_Pin|R1_Pin|B1_Pin
700006ca:	f44f 5376 	mov.w	r3, #15744	@ 0x3d80
700006ce:	617b      	str	r3, [r7, #20]
                          |R2_Pin|G1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
700006d0:	2301      	movs	r3, #1
700006d2:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
700006d4:	2300      	movs	r3, #0
700006d6:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
700006d8:	2302      	movs	r3, #2
700006da:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
700006dc:	f107 0314 	add.w	r3, r7, #20
700006e0:	4619      	mov	r1, r3
700006e2:	480e      	ldr	r0, [pc, #56]	@ (7000071c <MX_GPIO_Init+0x13c>)
700006e4:	f001 f8c0 	bl	70001868 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = G2_Pin;
700006e8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
700006ec:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
700006ee:	2301      	movs	r3, #1
700006f0:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
700006f2:	2300      	movs	r3, #0
700006f4:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
700006f6:	2302      	movs	r3, #2
700006f8:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(G2_GPIO_Port, &GPIO_InitStruct);
700006fa:	f107 0314 	add.w	r3, r7, #20
700006fe:	4619      	mov	r1, r3
70000700:	4807      	ldr	r0, [pc, #28]	@ (70000720 <MX_GPIO_Init+0x140>)
70000702:	f001 f8b1 	bl	70001868 <HAL_GPIO_Init>

}
70000706:	bf00      	nop
70000708:	3728      	adds	r7, #40	@ 0x28
7000070a:	46bd      	mov	sp, r7
7000070c:	bd80      	pop	{r7, pc}
7000070e:	bf00      	nop
70000710:	58024400 	.word	0x58024400
70000714:	58021400 	.word	0x58021400
70000718:	58020400 	.word	0x58020400
7000071c:	58021000 	.word	0x58021000
70000720:	58020000 	.word	0x58020000

70000724 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
70000724:	b580      	push	{r7, lr}
70000726:	b086      	sub	sp, #24
70000728:	af02      	add	r7, sp, #8
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
7000072a:	4b6a      	ldr	r3, [pc, #424]	@ (700008d4 <main+0x1b0>)
7000072c:	695b      	ldr	r3, [r3, #20]
7000072e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70000732:	2b00      	cmp	r3, #0
70000734:	d11b      	bne.n	7000076e <main+0x4a>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
70000736:	f3bf 8f4f 	dsb	sy
}
7000073a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
7000073c:	f3bf 8f6f 	isb	sy
}
70000740:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
70000742:	4b64      	ldr	r3, [pc, #400]	@ (700008d4 <main+0x1b0>)
70000744:	2200      	movs	r2, #0
70000746:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
7000074a:	f3bf 8f4f 	dsb	sy
}
7000074e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
70000750:	f3bf 8f6f 	isb	sy
}
70000754:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
70000756:	4b5f      	ldr	r3, [pc, #380]	@ (700008d4 <main+0x1b0>)
70000758:	695b      	ldr	r3, [r3, #20]
7000075a:	4a5e      	ldr	r2, [pc, #376]	@ (700008d4 <main+0x1b0>)
7000075c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
70000760:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
70000762:	f3bf 8f4f 	dsb	sy
}
70000766:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
70000768:	f3bf 8f6f 	isb	sy
}
7000076c:	e000      	b.n	70000770 <main+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
7000076e:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
70000770:	4b58      	ldr	r3, [pc, #352]	@ (700008d4 <main+0x1b0>)
70000772:	695b      	ldr	r3, [r3, #20]
70000774:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70000778:	2b00      	cmp	r3, #0
7000077a:	d138      	bne.n	700007ee <main+0xca>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
7000077c:	4b55      	ldr	r3, [pc, #340]	@ (700008d4 <main+0x1b0>)
7000077e:	2200      	movs	r2, #0
70000780:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
70000784:	f3bf 8f4f 	dsb	sy
}
70000788:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
7000078a:	4b52      	ldr	r3, [pc, #328]	@ (700008d4 <main+0x1b0>)
7000078c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
70000790:	60fb      	str	r3, [r7, #12]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
70000792:	68fb      	ldr	r3, [r7, #12]
70000794:	0b5b      	lsrs	r3, r3, #13
70000796:	f3c3 030e 	ubfx	r3, r3, #0, #15
7000079a:	60bb      	str	r3, [r7, #8]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
7000079c:	68fb      	ldr	r3, [r7, #12]
7000079e:	08db      	lsrs	r3, r3, #3
700007a0:	f3c3 0309 	ubfx	r3, r3, #0, #10
700007a4:	607b      	str	r3, [r7, #4]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
700007a6:	68bb      	ldr	r3, [r7, #8]
700007a8:	015a      	lsls	r2, r3, #5
700007aa:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
700007ae:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
700007b0:	687a      	ldr	r2, [r7, #4]
700007b2:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
700007b4:	4947      	ldr	r1, [pc, #284]	@ (700008d4 <main+0x1b0>)
700007b6:	4313      	orrs	r3, r2
700007b8:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
700007bc:	687b      	ldr	r3, [r7, #4]
700007be:	1e5a      	subs	r2, r3, #1
700007c0:	607a      	str	r2, [r7, #4]
700007c2:	2b00      	cmp	r3, #0
700007c4:	d1ef      	bne.n	700007a6 <main+0x82>
    } while(sets-- != 0U);
700007c6:	68bb      	ldr	r3, [r7, #8]
700007c8:	1e5a      	subs	r2, r3, #1
700007ca:	60ba      	str	r2, [r7, #8]
700007cc:	2b00      	cmp	r3, #0
700007ce:	d1e5      	bne.n	7000079c <main+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
700007d0:	f3bf 8f4f 	dsb	sy
}
700007d4:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
700007d6:	4b3f      	ldr	r3, [pc, #252]	@ (700008d4 <main+0x1b0>)
700007d8:	695b      	ldr	r3, [r3, #20]
700007da:	4a3e      	ldr	r2, [pc, #248]	@ (700008d4 <main+0x1b0>)
700007dc:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
700007e0:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
700007e2:	f3bf 8f4f 	dsb	sy
}
700007e6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
700007e8:	f3bf 8f6f 	isb	sy
}
700007ec:	e000      	b.n	700007f0 <main+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
700007ee:	bf00      	nop
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/

  /* Update SystemCoreClock variable according to RCC registers values. */
  SystemCoreClockUpdate();
700007f0:	f000 fa6c 	bl	70000ccc <SystemCoreClockUpdate>

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
700007f4:	f000 fe32 	bl	7000145c <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
700007f8:	f7ff fef2 	bl	700005e0 <MX_GPIO_Init>
  /* USER CODE BEGIN 2 */

  DWT_Init();
700007fc:	f000 f9c8 	bl	70000b90 <DWT_Init>
  HUB75_Init();
70000800:	f000 f86e 	bl	700008e0 <HUB75_Init>

  DrawPixel(15, 20, 200, 0, 0);
70000804:	2300      	movs	r3, #0
70000806:	9300      	str	r3, [sp, #0]
70000808:	2300      	movs	r3, #0
7000080a:	22c8      	movs	r2, #200	@ 0xc8
7000080c:	2114      	movs	r1, #20
7000080e:	200f      	movs	r0, #15
70000810:	f000 f986 	bl	70000b20 <DrawPixel>
  DrawPixel(15, 21, 0, 200, 0);
70000814:	2300      	movs	r3, #0
70000816:	9300      	str	r3, [sp, #0]
70000818:	23c8      	movs	r3, #200	@ 0xc8
7000081a:	2200      	movs	r2, #0
7000081c:	2115      	movs	r1, #21
7000081e:	200f      	movs	r0, #15
70000820:	f000 f97e 	bl	70000b20 <DrawPixel>
  DrawPixel(15, 22, 0, 0, 200);
70000824:	23c8      	movs	r3, #200	@ 0xc8
70000826:	9300      	str	r3, [sp, #0]
70000828:	2300      	movs	r3, #0
7000082a:	2200      	movs	r2, #0
7000082c:	2116      	movs	r1, #22
7000082e:	200f      	movs	r0, #15
70000830:	f000 f976 	bl	70000b20 <DrawPixel>
  DrawPixel(60, 25, 100, 100, 100);
70000834:	2364      	movs	r3, #100	@ 0x64
70000836:	9300      	str	r3, [sp, #0]
70000838:	2364      	movs	r3, #100	@ 0x64
7000083a:	2264      	movs	r2, #100	@ 0x64
7000083c:	2119      	movs	r1, #25
7000083e:	203c      	movs	r0, #60	@ 0x3c
70000840:	f000 f96e 	bl	70000b20 <DrawPixel>
  DrawPixel(61, 25, 200, 200, 200);
70000844:	23c8      	movs	r3, #200	@ 0xc8
70000846:	9300      	str	r3, [sp, #0]
70000848:	23c8      	movs	r3, #200	@ 0xc8
7000084a:	22c8      	movs	r2, #200	@ 0xc8
7000084c:	2119      	movs	r1, #25
7000084e:	203d      	movs	r0, #61	@ 0x3d
70000850:	f000 f966 	bl	70000b20 <DrawPixel>
  DrawPixel(62, 25, 10, 10, 10);
70000854:	230a      	movs	r3, #10
70000856:	9300      	str	r3, [sp, #0]
70000858:	230a      	movs	r3, #10
7000085a:	220a      	movs	r2, #10
7000085c:	2119      	movs	r1, #25
7000085e:	203e      	movs	r0, #62	@ 0x3e
70000860:	f000 f95e 	bl	70000b20 <DrawPixel>
  DrawPixel(30, 20, 255, 255, 255);
70000864:	23ff      	movs	r3, #255	@ 0xff
70000866:	9300      	str	r3, [sp, #0]
70000868:	23ff      	movs	r3, #255	@ 0xff
7000086a:	22ff      	movs	r2, #255	@ 0xff
7000086c:	2114      	movs	r1, #20
7000086e:	201e      	movs	r0, #30
70000870:	f000 f956 	bl	70000b20 <DrawPixel>
//  DrawRectangle(0, 0, 63, 32, 0, 1, 0);

  /* USER CODE END 2 */

  /* Initialize leds */
  BSP_LED_Init(LED_GREEN);
70000874:	2000      	movs	r0, #0
70000876:	f000 fb8b 	bl	70000f90 <BSP_LED_Init>
  BSP_LED_Init(LED_BLUE);
7000087a:	2001      	movs	r0, #1
7000087c:	f000 fb88 	bl	70000f90 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
70000880:	2002      	movs	r0, #2
70000882:	f000 fb85 	bl	70000f90 <BSP_LED_Init>

  /* Initialize USER push-button, will be used to trigger an interrupt each time it's pressed.*/
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
70000886:	2101      	movs	r1, #1
70000888:	2000      	movs	r0, #0
7000088a:	f000 fbfd 	bl	70001088 <BSP_PB_Init>

  /* Initialize COM1 port (115200, 8 bits (7-bit data + 1 stop bit), no parity */
  BspCOMInit.BaudRate   = 115200;
7000088e:	4b12      	ldr	r3, [pc, #72]	@ (700008d8 <main+0x1b4>)
70000890:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
70000894:	601a      	str	r2, [r3, #0]
  BspCOMInit.WordLength = COM_WORDLENGTH_8B;
70000896:	4b10      	ldr	r3, [pc, #64]	@ (700008d8 <main+0x1b4>)
70000898:	2200      	movs	r2, #0
7000089a:	605a      	str	r2, [r3, #4]
  BspCOMInit.StopBits   = COM_STOPBITS_1;
7000089c:	4b0e      	ldr	r3, [pc, #56]	@ (700008d8 <main+0x1b4>)
7000089e:	2200      	movs	r2, #0
700008a0:	811a      	strh	r2, [r3, #8]
  BspCOMInit.Parity     = COM_PARITY_NONE;
700008a2:	4b0d      	ldr	r3, [pc, #52]	@ (700008d8 <main+0x1b4>)
700008a4:	2200      	movs	r2, #0
700008a6:	815a      	strh	r2, [r3, #10]
  BspCOMInit.HwFlowCtl  = COM_HWCONTROL_NONE;
700008a8:	4b0b      	ldr	r3, [pc, #44]	@ (700008d8 <main+0x1b4>)
700008aa:	2200      	movs	r2, #0
700008ac:	819a      	strh	r2, [r3, #12]
  if (BSP_COM_Init(COM1, &BspCOMInit) != BSP_ERROR_NONE)
700008ae:	490a      	ldr	r1, [pc, #40]	@ (700008d8 <main+0x1b4>)
700008b0:	2000      	movs	r0, #0
700008b2:	f000 fcb5 	bl	70001220 <BSP_COM_Init>
700008b6:	4603      	mov	r3, r0
700008b8:	2b00      	cmp	r3, #0
700008ba:	d001      	beq.n	700008c0 <main+0x19c>
  {
    Error_Handler();
700008bc:	f000 f9ac 	bl	70000c18 <Error_Handler>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  HAL_GPIO_TogglePin(LD1_GPIO_PORT, LD1_PIN);
700008c0:	f44f 6180 	mov.w	r1, #1024	@ 0x400
700008c4:	4805      	ldr	r0, [pc, #20]	@ (700008dc <main+0x1b8>)
700008c6:	f001 f93d 	bl	70001b44 <HAL_GPIO_TogglePin>

	  HUB75_SendRowData();
700008ca:	f000 f827 	bl	7000091c <HUB75_SendRowData>
	  HAL_GPIO_TogglePin(LD1_GPIO_PORT, LD1_PIN);
700008ce:	bf00      	nop
700008d0:	e7f6      	b.n	700008c0 <main+0x19c>
700008d2:	bf00      	nop
700008d4:	e000ed00 	.word	0xe000ed00
700008d8:	2400004c 	.word	0x2400004c
700008dc:	58020c00 	.word	0x58020c00

700008e0 <HUB75_Init>:
  /* USER CODE END 3 */
}

/* USER CODE BEGIN 4 */

void HUB75_Init(void) {
700008e0:	b580      	push	{r7, lr}
700008e2:	af00      	add	r7, sp, #0
    // Reset all control lines initially
    RGB_OE(0);  // Disable output
700008e4:	2200      	movs	r2, #0
700008e6:	f44f 7180 	mov.w	r1, #256	@ 0x100
700008ea:	4809      	ldr	r0, [pc, #36]	@ (70000910 <HUB75_Init+0x30>)
700008ec:	f001 f912 	bl	70001b14 <HAL_GPIO_WritePin>
    RGB_LAT(0); // Latch low
700008f0:	2200      	movs	r2, #0
700008f2:	f44f 7100 	mov.w	r1, #512	@ 0x200
700008f6:	4806      	ldr	r0, [pc, #24]	@ (70000910 <HUB75_Init+0x30>)
700008f8:	f001 f90c 	bl	70001b14 <HAL_GPIO_WritePin>
    RGB_CLK(0); // Clock low
700008fc:	2200      	movs	r2, #0
700008fe:	2110      	movs	r1, #16
70000900:	4804      	ldr	r0, [pc, #16]	@ (70000914 <HUB75_Init+0x34>)
70000902:	f001 f907 	bl	70001b14 <HAL_GPIO_WritePin>

    Paint_NewImage(ImageBuffer);
70000906:	4804      	ldr	r0, [pc, #16]	@ (70000918 <HUB75_Init+0x38>)
70000908:	f000 f8fa 	bl	70000b00 <Paint_NewImage>
}
7000090c:	bf00      	nop
7000090e:	bd80      	pop	{r7, pc}
70000910:	58020400 	.word	0x58020400
70000914:	58021400 	.word	0x58021400
70000918:	2400005c 	.word	0x2400005c

7000091c <HUB75_SendRowData>:

void HUB75_SendRowData(void) {
7000091c:	b580      	push	{r7, lr}
7000091e:	b084      	sub	sp, #16
70000920:	af00      	add	r7, sp, #0
	for (uint16_t row = 0; row < MATRIX_HEIGHT / 2; row++) {
70000922:	2300      	movs	r3, #0
70000924:	81fb      	strh	r3, [r7, #14]
70000926:	e0d7      	b.n	70000ad8 <HUB75_SendRowData+0x1bc>
		// Set row address (A, B, C, D pins)
		RGB_A(row);
70000928:	89fb      	ldrh	r3, [r7, #14]
7000092a:	b2db      	uxtb	r3, r3
7000092c:	f003 0301 	and.w	r3, r3, #1
70000930:	b2db      	uxtb	r3, r3
70000932:	461a      	mov	r2, r3
70000934:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
70000938:	486c      	ldr	r0, [pc, #432]	@ (70000aec <HUB75_SendRowData+0x1d0>)
7000093a:	f001 f8eb 	bl	70001b14 <HAL_GPIO_WritePin>
		RGB_B(row);
7000093e:	89fb      	ldrh	r3, [r7, #14]
70000940:	105b      	asrs	r3, r3, #1
70000942:	b2db      	uxtb	r3, r3
70000944:	f003 0301 	and.w	r3, r3, #1
70000948:	b2db      	uxtb	r3, r3
7000094a:	461a      	mov	r2, r3
7000094c:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
70000950:	4867      	ldr	r0, [pc, #412]	@ (70000af0 <HUB75_SendRowData+0x1d4>)
70000952:	f001 f8df 	bl	70001b14 <HAL_GPIO_WritePin>
		RGB_C(row);
70000956:	89fb      	ldrh	r3, [r7, #14]
70000958:	109b      	asrs	r3, r3, #2
7000095a:	b2db      	uxtb	r3, r3
7000095c:	f003 0301 	and.w	r3, r3, #1
70000960:	b2db      	uxtb	r3, r3
70000962:	461a      	mov	r2, r3
70000964:	2108      	movs	r1, #8
70000966:	4861      	ldr	r0, [pc, #388]	@ (70000aec <HUB75_SendRowData+0x1d0>)
70000968:	f001 f8d4 	bl	70001b14 <HAL_GPIO_WritePin>
		RGB_D(row);
7000096c:	89fb      	ldrh	r3, [r7, #14]
7000096e:	10db      	asrs	r3, r3, #3
70000970:	b2db      	uxtb	r3, r3
70000972:	f003 0301 	and.w	r3, r3, #1
70000976:	b2db      	uxtb	r3, r3
70000978:	461a      	mov	r2, r3
7000097a:	f44f 6100 	mov.w	r1, #2048	@ 0x800
7000097e:	485c      	ldr	r0, [pc, #368]	@ (70000af0 <HUB75_SendRowData+0x1d4>)
70000980:	f001 f8c8 	bl	70001b14 <HAL_GPIO_WritePin>

		DelayUs(10);
70000984:	200a      	movs	r0, #10
70000986:	f000 f923 	bl	70000bd0 <DelayUs>

		for (uint16_t col = 0; col < MATRIX_WIDTH; col++) {
7000098a:	2300      	movs	r3, #0
7000098c:	81bb      	strh	r3, [r7, #12]
7000098e:	e084      	b.n	70000a9a <HUB75_SendRowData+0x17e>
			uint32_t index_upper = (MATRIX_WIDTH - col - 1) + ((MATRIX_HEIGHT - row - 1) * MATRIX_WIDTH);
70000990:	89bb      	ldrh	r3, [r7, #12]
70000992:	f1c3 023f 	rsb	r2, r3, #63	@ 0x3f
70000996:	89fb      	ldrh	r3, [r7, #14]
70000998:	f1c3 031f 	rsb	r3, r3, #31
7000099c:	019b      	lsls	r3, r3, #6
7000099e:	4413      	add	r3, r2
700009a0:	60bb      	str	r3, [r7, #8]
			index_upper *= 3;
700009a2:	68ba      	ldr	r2, [r7, #8]
700009a4:	4613      	mov	r3, r2
700009a6:	005b      	lsls	r3, r3, #1
700009a8:	4413      	add	r3, r2
700009aa:	60bb      	str	r3, [r7, #8]

			RGB_R1(ImageBuffer[index_upper]);
700009ac:	4a51      	ldr	r2, [pc, #324]	@ (70000af4 <HUB75_SendRowData+0x1d8>)
700009ae:	68bb      	ldr	r3, [r7, #8]
700009b0:	4413      	add	r3, r2
700009b2:	781b      	ldrb	r3, [r3, #0]
700009b4:	2b00      	cmp	r3, #0
700009b6:	bf14      	ite	ne
700009b8:	2301      	movne	r3, #1
700009ba:	2300      	moveq	r3, #0
700009bc:	b2db      	uxtb	r3, r3
700009be:	461a      	mov	r2, r3
700009c0:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
700009c4:	484a      	ldr	r0, [pc, #296]	@ (70000af0 <HUB75_SendRowData+0x1d4>)
700009c6:	f001 f8a5 	bl	70001b14 <HAL_GPIO_WritePin>
			RGB_G1(ImageBuffer[index_upper + 1]);
700009ca:	68bb      	ldr	r3, [r7, #8]
700009cc:	3301      	adds	r3, #1
700009ce:	4a49      	ldr	r2, [pc, #292]	@ (70000af4 <HUB75_SendRowData+0x1d8>)
700009d0:	5cd3      	ldrb	r3, [r2, r3]
700009d2:	2b00      	cmp	r3, #0
700009d4:	bf14      	ite	ne
700009d6:	2301      	movne	r3, #1
700009d8:	2300      	moveq	r3, #0
700009da:	b2db      	uxtb	r3, r3
700009dc:	461a      	mov	r2, r3
700009de:	f44f 6180 	mov.w	r1, #1024	@ 0x400
700009e2:	4843      	ldr	r0, [pc, #268]	@ (70000af0 <HUB75_SendRowData+0x1d4>)
700009e4:	f001 f896 	bl	70001b14 <HAL_GPIO_WritePin>
			RGB_B1(ImageBuffer[index_upper + 2]);
700009e8:	68bb      	ldr	r3, [r7, #8]
700009ea:	3302      	adds	r3, #2
700009ec:	4a41      	ldr	r2, [pc, #260]	@ (70000af4 <HUB75_SendRowData+0x1d8>)
700009ee:	5cd3      	ldrb	r3, [r2, r3]
700009f0:	2b00      	cmp	r3, #0
700009f2:	bf14      	ite	ne
700009f4:	2301      	movne	r3, #1
700009f6:	2300      	moveq	r3, #0
700009f8:	b2db      	uxtb	r3, r3
700009fa:	461a      	mov	r2, r3
700009fc:	2180      	movs	r1, #128	@ 0x80
700009fe:	483c      	ldr	r0, [pc, #240]	@ (70000af0 <HUB75_SendRowData+0x1d4>)
70000a00:	f001 f888 	bl	70001b14 <HAL_GPIO_WritePin>

			uint32_t index_lower = (MATRIX_WIDTH - col - 1) + ((MATRIX_HEIGHT - (row + 16) - 1) * MATRIX_WIDTH);
70000a04:	89bb      	ldrh	r3, [r7, #12]
70000a06:	f1c3 023f 	rsb	r2, r3, #63	@ 0x3f
70000a0a:	89fb      	ldrh	r3, [r7, #14]
70000a0c:	f1c3 030f 	rsb	r3, r3, #15
70000a10:	019b      	lsls	r3, r3, #6
70000a12:	4413      	add	r3, r2
70000a14:	607b      	str	r3, [r7, #4]
			index_lower *= 3;
70000a16:	687a      	ldr	r2, [r7, #4]
70000a18:	4613      	mov	r3, r2
70000a1a:	005b      	lsls	r3, r3, #1
70000a1c:	4413      	add	r3, r2
70000a1e:	607b      	str	r3, [r7, #4]

			RGB_R2(ImageBuffer[index_lower]);
70000a20:	4a34      	ldr	r2, [pc, #208]	@ (70000af4 <HUB75_SendRowData+0x1d8>)
70000a22:	687b      	ldr	r3, [r7, #4]
70000a24:	4413      	add	r3, r2
70000a26:	781b      	ldrb	r3, [r3, #0]
70000a28:	2b00      	cmp	r3, #0
70000a2a:	bf14      	ite	ne
70000a2c:	2301      	movne	r3, #1
70000a2e:	2300      	moveq	r3, #0
70000a30:	b2db      	uxtb	r3, r3
70000a32:	461a      	mov	r2, r3
70000a34:	f44f 7180 	mov.w	r1, #256	@ 0x100
70000a38:	482d      	ldr	r0, [pc, #180]	@ (70000af0 <HUB75_SendRowData+0x1d4>)
70000a3a:	f001 f86b 	bl	70001b14 <HAL_GPIO_WritePin>
			RGB_G2(ImageBuffer[index_lower + 1]);
70000a3e:	687b      	ldr	r3, [r7, #4]
70000a40:	3301      	adds	r3, #1
70000a42:	4a2c      	ldr	r2, [pc, #176]	@ (70000af4 <HUB75_SendRowData+0x1d8>)
70000a44:	5cd3      	ldrb	r3, [r2, r3]
70000a46:	2b00      	cmp	r3, #0
70000a48:	bf14      	ite	ne
70000a4a:	2301      	movne	r3, #1
70000a4c:	2300      	moveq	r3, #0
70000a4e:	b2db      	uxtb	r3, r3
70000a50:	461a      	mov	r2, r3
70000a52:	f44f 6180 	mov.w	r1, #1024	@ 0x400
70000a56:	4828      	ldr	r0, [pc, #160]	@ (70000af8 <HUB75_SendRowData+0x1dc>)
70000a58:	f001 f85c 	bl	70001b14 <HAL_GPIO_WritePin>
			RGB_B2(ImageBuffer[index_lower + 2]);
70000a5c:	687b      	ldr	r3, [r7, #4]
70000a5e:	3302      	adds	r3, #2
70000a60:	4a24      	ldr	r2, [pc, #144]	@ (70000af4 <HUB75_SendRowData+0x1d8>)
70000a62:	5cd3      	ldrb	r3, [r2, r3]
70000a64:	2b00      	cmp	r3, #0
70000a66:	bf14      	ite	ne
70000a68:	2301      	movne	r3, #1
70000a6a:	2300      	moveq	r3, #0
70000a6c:	b2db      	uxtb	r3, r3
70000a6e:	461a      	mov	r2, r3
70000a70:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
70000a74:	4821      	ldr	r0, [pc, #132]	@ (70000afc <HUB75_SendRowData+0x1e0>)
70000a76:	f001 f84d 	bl	70001b14 <HAL_GPIO_WritePin>

			RGB_CLK(1);
70000a7a:	2201      	movs	r2, #1
70000a7c:	2110      	movs	r1, #16
70000a7e:	481b      	ldr	r0, [pc, #108]	@ (70000aec <HUB75_SendRowData+0x1d0>)
70000a80:	f001 f848 	bl	70001b14 <HAL_GPIO_WritePin>
			DelayUs(5);
70000a84:	2005      	movs	r0, #5
70000a86:	f000 f8a3 	bl	70000bd0 <DelayUs>
			RGB_CLK(0);
70000a8a:	2200      	movs	r2, #0
70000a8c:	2110      	movs	r1, #16
70000a8e:	4817      	ldr	r0, [pc, #92]	@ (70000aec <HUB75_SendRowData+0x1d0>)
70000a90:	f001 f840 	bl	70001b14 <HAL_GPIO_WritePin>
		for (uint16_t col = 0; col < MATRIX_WIDTH; col++) {
70000a94:	89bb      	ldrh	r3, [r7, #12]
70000a96:	3301      	adds	r3, #1
70000a98:	81bb      	strh	r3, [r7, #12]
70000a9a:	89bb      	ldrh	r3, [r7, #12]
70000a9c:	2b3f      	cmp	r3, #63	@ 0x3f
70000a9e:	f67f af77 	bls.w	70000990 <HUB75_SendRowData+0x74>
		}

		RGB_LAT(1);
70000aa2:	2201      	movs	r2, #1
70000aa4:	f44f 7100 	mov.w	r1, #512	@ 0x200
70000aa8:	4814      	ldr	r0, [pc, #80]	@ (70000afc <HUB75_SendRowData+0x1e0>)
70000aaa:	f001 f833 	bl	70001b14 <HAL_GPIO_WritePin>
		RGB_LAT(0);
70000aae:	2200      	movs	r2, #0
70000ab0:	f44f 7100 	mov.w	r1, #512	@ 0x200
70000ab4:	4811      	ldr	r0, [pc, #68]	@ (70000afc <HUB75_SendRowData+0x1e0>)
70000ab6:	f001 f82d 	bl	70001b14 <HAL_GPIO_WritePin>

		RGB_OE(1);
70000aba:	2201      	movs	r2, #1
70000abc:	f44f 7180 	mov.w	r1, #256	@ 0x100
70000ac0:	480e      	ldr	r0, [pc, #56]	@ (70000afc <HUB75_SendRowData+0x1e0>)
70000ac2:	f001 f827 	bl	70001b14 <HAL_GPIO_WritePin>
//		DelayUs(1);
		RGB_OE(0);
70000ac6:	2200      	movs	r2, #0
70000ac8:	f44f 7180 	mov.w	r1, #256	@ 0x100
70000acc:	480b      	ldr	r0, [pc, #44]	@ (70000afc <HUB75_SendRowData+0x1e0>)
70000ace:	f001 f821 	bl	70001b14 <HAL_GPIO_WritePin>
	for (uint16_t row = 0; row < MATRIX_HEIGHT / 2; row++) {
70000ad2:	89fb      	ldrh	r3, [r7, #14]
70000ad4:	3301      	adds	r3, #1
70000ad6:	81fb      	strh	r3, [r7, #14]
70000ad8:	89fb      	ldrh	r3, [r7, #14]
70000ada:	2b0f      	cmp	r3, #15
70000adc:	f67f af24 	bls.w	70000928 <HUB75_SendRowData+0xc>
	}
}
70000ae0:	bf00      	nop
70000ae2:	bf00      	nop
70000ae4:	3710      	adds	r7, #16
70000ae6:	46bd      	mov	sp, r7
70000ae8:	bd80      	pop	{r7, pc}
70000aea:	bf00      	nop
70000aec:	58021400 	.word	0x58021400
70000af0:	58021000 	.word	0x58021000
70000af4:	2400005c 	.word	0x2400005c
70000af8:	58020000 	.word	0x58020000
70000afc:	58020400 	.word	0x58020400

70000b00 <Paint_NewImage>:

void Paint_NewImage(uint8_t image[])
{
70000b00:	b480      	push	{r7}
70000b02:	b083      	sub	sp, #12
70000b04:	af00      	add	r7, sp, #0
70000b06:	6078      	str	r0, [r7, #4]
	Image = image;
70000b08:	4a04      	ldr	r2, [pc, #16]	@ (70000b1c <Paint_NewImage+0x1c>)
70000b0a:	687b      	ldr	r3, [r7, #4]
70000b0c:	6013      	str	r3, [r2, #0]
}
70000b0e:	bf00      	nop
70000b10:	370c      	adds	r7, #12
70000b12:	46bd      	mov	sp, r7
70000b14:	f85d 7b04 	ldr.w	r7, [sp], #4
70000b18:	4770      	bx	lr
70000b1a:	bf00      	nop
70000b1c:	2400185c 	.word	0x2400185c

70000b20 <DrawPixel>:

void DrawPixel(uint16_t Xpoint, uint16_t Ypoint, uint8_t R, uint8_t G, uint8_t B)
{
70000b20:	b490      	push	{r4, r7}
70000b22:	b084      	sub	sp, #16
70000b24:	af00      	add	r7, sp, #0
70000b26:	4604      	mov	r4, r0
70000b28:	4608      	mov	r0, r1
70000b2a:	4611      	mov	r1, r2
70000b2c:	461a      	mov	r2, r3
70000b2e:	4623      	mov	r3, r4
70000b30:	80fb      	strh	r3, [r7, #6]
70000b32:	4603      	mov	r3, r0
70000b34:	80bb      	strh	r3, [r7, #4]
70000b36:	460b      	mov	r3, r1
70000b38:	70fb      	strb	r3, [r7, #3]
70000b3a:	4613      	mov	r3, r2
70000b3c:	70bb      	strb	r3, [r7, #2]
	// Calculate the index for the pixel, each pixel takes 3 bytes
	uint32_t index = (MATRIX_WIDTH - Xpoint - 1) + ((MATRIX_HEIGHT - Ypoint - 1) * MATRIX_WIDTH);
70000b3e:	88fb      	ldrh	r3, [r7, #6]
70000b40:	f1c3 023f 	rsb	r2, r3, #63	@ 0x3f
70000b44:	88bb      	ldrh	r3, [r7, #4]
70000b46:	f1c3 031f 	rsb	r3, r3, #31
70000b4a:	019b      	lsls	r3, r3, #6
70000b4c:	4413      	add	r3, r2
70000b4e:	60fb      	str	r3, [r7, #12]
	index *= 3; // Each pixel has 3 bytes (R, G, B)
70000b50:	68fa      	ldr	r2, [r7, #12]
70000b52:	4613      	mov	r3, r2
70000b54:	005b      	lsls	r3, r3, #1
70000b56:	4413      	add	r3, r2
70000b58:	60fb      	str	r3, [r7, #12]

	Image[index] = R; 			// Red value
70000b5a:	4b0c      	ldr	r3, [pc, #48]	@ (70000b8c <DrawPixel+0x6c>)
70000b5c:	681a      	ldr	r2, [r3, #0]
70000b5e:	68fb      	ldr	r3, [r7, #12]
70000b60:	4413      	add	r3, r2
70000b62:	78fa      	ldrb	r2, [r7, #3]
70000b64:	701a      	strb	r2, [r3, #0]
	Image[index + 1] = G; 	// Green value
70000b66:	4b09      	ldr	r3, [pc, #36]	@ (70000b8c <DrawPixel+0x6c>)
70000b68:	681a      	ldr	r2, [r3, #0]
70000b6a:	68fb      	ldr	r3, [r7, #12]
70000b6c:	3301      	adds	r3, #1
70000b6e:	4413      	add	r3, r2
70000b70:	78ba      	ldrb	r2, [r7, #2]
70000b72:	701a      	strb	r2, [r3, #0]
	Image[index + 2] = B; 	// Blue value
70000b74:	4b05      	ldr	r3, [pc, #20]	@ (70000b8c <DrawPixel+0x6c>)
70000b76:	681a      	ldr	r2, [r3, #0]
70000b78:	68fb      	ldr	r3, [r7, #12]
70000b7a:	3302      	adds	r3, #2
70000b7c:	4413      	add	r3, r2
70000b7e:	7e3a      	ldrb	r2, [r7, #24]
70000b80:	701a      	strb	r2, [r3, #0]
}
70000b82:	bf00      	nop
70000b84:	3710      	adds	r7, #16
70000b86:	46bd      	mov	sp, r7
70000b88:	bc90      	pop	{r4, r7}
70000b8a:	4770      	bx	lr
70000b8c:	2400185c 	.word	0x2400185c

70000b90 <DWT_Init>:
    }
}


// Function to initialize the DWT cycle counter
void DWT_Init(void) {
70000b90:	b480      	push	{r7}
70000b92:	af00      	add	r7, sp, #0
    // Enable TRC (Trace Control) for DWT
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
70000b94:	4b0b      	ldr	r3, [pc, #44]	@ (70000bc4 <DWT_Init+0x34>)
70000b96:	68db      	ldr	r3, [r3, #12]
70000b98:	4a0a      	ldr	r2, [pc, #40]	@ (70000bc4 <DWT_Init+0x34>)
70000b9a:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
70000b9e:	60d3      	str	r3, [r2, #12]

    // Unlock the DWT (Data Watchpoint and Trace) registers
	// On STM32H7, this is necessary to access DWT->CYCCNT
    DWT->LAR = 0xC5ACCE55;
70000ba0:	4b09      	ldr	r3, [pc, #36]	@ (70000bc8 <DWT_Init+0x38>)
70000ba2:	4a0a      	ldr	r2, [pc, #40]	@ (70000bcc <DWT_Init+0x3c>)
70000ba4:	f8c3 2fb0 	str.w	r2, [r3, #4016]	@ 0xfb0

    // Reset the cycle counter
	DWT->CYCCNT = 0;
70000ba8:	4b07      	ldr	r3, [pc, #28]	@ (70000bc8 <DWT_Init+0x38>)
70000baa:	2200      	movs	r2, #0
70000bac:	605a      	str	r2, [r3, #4]

    // Enable the cycle counter
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
70000bae:	4b06      	ldr	r3, [pc, #24]	@ (70000bc8 <DWT_Init+0x38>)
70000bb0:	681b      	ldr	r3, [r3, #0]
70000bb2:	4a05      	ldr	r2, [pc, #20]	@ (70000bc8 <DWT_Init+0x38>)
70000bb4:	f043 0301 	orr.w	r3, r3, #1
70000bb8:	6013      	str	r3, [r2, #0]
}
70000bba:	bf00      	nop
70000bbc:	46bd      	mov	sp, r7
70000bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
70000bc2:	4770      	bx	lr
70000bc4:	e000edf0 	.word	0xe000edf0
70000bc8:	e0001000 	.word	0xe0001000
70000bcc:	c5acce55 	.word	0xc5acce55

70000bd0 <DelayUs>:

// Function to delay in microseconds
void DelayUs(uint32_t us) {
70000bd0:	b580      	push	{r7, lr}
70000bd2:	b084      	sub	sp, #16
70000bd4:	af00      	add	r7, sp, #0
70000bd6:	6078      	str	r0, [r7, #4]
    uint32_t startTick = DWT->CYCCNT;
70000bd8:	4b0d      	ldr	r3, [pc, #52]	@ (70000c10 <DelayUs+0x40>)
70000bda:	685b      	ldr	r3, [r3, #4]
70000bdc:	60fb      	str	r3, [r7, #12]
    uint32_t usTicks = us * (HAL_RCC_GetHCLKFreq() / 1000000); // Clock cycles per microsecond
70000bde:	f001 f931 	bl	70001e44 <HAL_RCC_GetHCLKFreq>
70000be2:	4603      	mov	r3, r0
70000be4:	4a0b      	ldr	r2, [pc, #44]	@ (70000c14 <DelayUs+0x44>)
70000be6:	fba2 2303 	umull	r2, r3, r2, r3
70000bea:	0c9a      	lsrs	r2, r3, #18
70000bec:	687b      	ldr	r3, [r7, #4]
70000bee:	fb02 f303 	mul.w	r3, r2, r3
70000bf2:	60bb      	str	r3, [r7, #8]

    while ((DWT->CYCCNT - startTick) < usTicks);
70000bf4:	bf00      	nop
70000bf6:	4b06      	ldr	r3, [pc, #24]	@ (70000c10 <DelayUs+0x40>)
70000bf8:	685a      	ldr	r2, [r3, #4]
70000bfa:	68fb      	ldr	r3, [r7, #12]
70000bfc:	1ad3      	subs	r3, r2, r3
70000bfe:	68ba      	ldr	r2, [r7, #8]
70000c00:	429a      	cmp	r2, r3
70000c02:	d8f8      	bhi.n	70000bf6 <DelayUs+0x26>
}
70000c04:	bf00      	nop
70000c06:	bf00      	nop
70000c08:	3710      	adds	r7, #16
70000c0a:	46bd      	mov	sp, r7
70000c0c:	bd80      	pop	{r7, pc}
70000c0e:	bf00      	nop
70000c10:	e0001000 	.word	0xe0001000
70000c14:	431bde83 	.word	0x431bde83

70000c18 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
70000c18:	b480      	push	{r7}
70000c1a:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
70000c1c:	b672      	cpsid	i
}
70000c1e:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
70000c20:	bf00      	nop
70000c22:	e7fd      	b.n	70000c20 <Error_Handler+0x8>

70000c24 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
70000c24:	b480      	push	{r7}
70000c26:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
70000c28:	bf00      	nop
70000c2a:	46bd      	mov	sp, r7
70000c2c:	f85d 7b04 	ldr.w	r7, [sp], #4
70000c30:	4770      	bx	lr

70000c32 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
70000c32:	b480      	push	{r7}
70000c34:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
70000c36:	bf00      	nop
70000c38:	e7fd      	b.n	70000c36 <NMI_Handler+0x4>

70000c3a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
70000c3a:	b480      	push	{r7}
70000c3c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
70000c3e:	bf00      	nop
70000c40:	e7fd      	b.n	70000c3e <HardFault_Handler+0x4>

70000c42 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
70000c42:	b480      	push	{r7}
70000c44:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
70000c46:	bf00      	nop
70000c48:	e7fd      	b.n	70000c46 <MemManage_Handler+0x4>

70000c4a <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
70000c4a:	b480      	push	{r7}
70000c4c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
70000c4e:	bf00      	nop
70000c50:	e7fd      	b.n	70000c4e <BusFault_Handler+0x4>

70000c52 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
70000c52:	b480      	push	{r7}
70000c54:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
70000c56:	bf00      	nop
70000c58:	e7fd      	b.n	70000c56 <UsageFault_Handler+0x4>

70000c5a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
70000c5a:	b480      	push	{r7}
70000c5c:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
70000c5e:	bf00      	nop
70000c60:	46bd      	mov	sp, r7
70000c62:	f85d 7b04 	ldr.w	r7, [sp], #4
70000c66:	4770      	bx	lr

70000c68 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
70000c68:	b480      	push	{r7}
70000c6a:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
70000c6c:	bf00      	nop
70000c6e:	46bd      	mov	sp, r7
70000c70:	f85d 7b04 	ldr.w	r7, [sp], #4
70000c74:	4770      	bx	lr

70000c76 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
70000c76:	b480      	push	{r7}
70000c78:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
70000c7a:	bf00      	nop
70000c7c:	46bd      	mov	sp, r7
70000c7e:	f85d 7b04 	ldr.w	r7, [sp], #4
70000c82:	4770      	bx	lr

70000c84 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
70000c84:	b580      	push	{r7, lr}
70000c86:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
70000c88:	f000 fc3c 	bl	70001504 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
70000c8c:	bf00      	nop
70000c8e:	bd80      	pop	{r7, pc}

70000c90 <EXTI13_IRQHandler>:

/**
  * @brief This function handles EXTI line13 interrupt.
  */
void EXTI13_IRQHandler(void)
{
70000c90:	b580      	push	{r7, lr}
70000c92:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI13_IRQn 0 */

  /* USER CODE END EXTI13_IRQn 0 */
  BSP_PB_IRQHandler(BUTTON_USER);
70000c94:	2000      	movs	r0, #0
70000c96:	f000 fab1 	bl	700011fc <BSP_PB_IRQHandler>
  /* USER CODE BEGIN EXTI13_IRQn 1 */

  /* USER CODE END EXTI13_IRQn 1 */
}
70000c9a:	bf00      	nop
70000c9c:	bd80      	pop	{r7, pc}
	...

70000ca0 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
70000ca0:	b480      	push	{r7}
70000ca2:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location -------------------------------------*/
  SCB->VTOR = INTVECT_START;
70000ca4:	4b07      	ldr	r3, [pc, #28]	@ (70000cc4 <SystemInit+0x24>)
70000ca6:	4a08      	ldr	r2, [pc, #32]	@ (70000cc8 <SystemInit+0x28>)
70000ca8:	609a      	str	r2, [r3, #8]

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
70000caa:	4b06      	ldr	r3, [pc, #24]	@ (70000cc4 <SystemInit+0x24>)
70000cac:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
70000cb0:	4a04      	ldr	r2, [pc, #16]	@ (70000cc4 <SystemInit+0x24>)
70000cb2:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
70000cb6:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif
}
70000cba:	bf00      	nop
70000cbc:	46bd      	mov	sp, r7
70000cbe:	f85d 7b04 	ldr.w	r7, [sp], #4
70000cc2:	4770      	bx	lr
70000cc4:	e000ed00 	.word	0xe000ed00
70000cc8:	70000000 	.word	0x70000000

70000ccc <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
70000ccc:	b480      	push	{r7}
70000cce:	b089      	sub	sp, #36	@ 0x24
70000cd0:	af00      	add	r7, sp, #0
  uint32_t sysclk, hsivalue, pllsource, pllm, pllp, core_presc;
  float_t pllfracn, pllvco;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
70000cd2:	4b92      	ldr	r3, [pc, #584]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000cd4:	691b      	ldr	r3, [r3, #16]
70000cd6:	f003 0338 	and.w	r3, r3, #56	@ 0x38
70000cda:	2b18      	cmp	r3, #24
70000cdc:	f200 80fb 	bhi.w	70000ed6 <SystemCoreClockUpdate+0x20a>
70000ce0:	a201      	add	r2, pc, #4	@ (adr r2, 70000ce8 <SystemCoreClockUpdate+0x1c>)
70000ce2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70000ce6:	bf00      	nop
70000ce8:	70000d4d 	.word	0x70000d4d
70000cec:	70000ed7 	.word	0x70000ed7
70000cf0:	70000ed7 	.word	0x70000ed7
70000cf4:	70000ed7 	.word	0x70000ed7
70000cf8:	70000ed7 	.word	0x70000ed7
70000cfc:	70000ed7 	.word	0x70000ed7
70000d00:	70000ed7 	.word	0x70000ed7
70000d04:	70000ed7 	.word	0x70000ed7
70000d08:	70000d61 	.word	0x70000d61
70000d0c:	70000ed7 	.word	0x70000ed7
70000d10:	70000ed7 	.word	0x70000ed7
70000d14:	70000ed7 	.word	0x70000ed7
70000d18:	70000ed7 	.word	0x70000ed7
70000d1c:	70000ed7 	.word	0x70000ed7
70000d20:	70000ed7 	.word	0x70000ed7
70000d24:	70000ed7 	.word	0x70000ed7
70000d28:	70000d67 	.word	0x70000d67
70000d2c:	70000ed7 	.word	0x70000ed7
70000d30:	70000ed7 	.word	0x70000ed7
70000d34:	70000ed7 	.word	0x70000ed7
70000d38:	70000ed7 	.word	0x70000ed7
70000d3c:	70000ed7 	.word	0x70000ed7
70000d40:	70000ed7 	.word	0x70000ed7
70000d44:	70000ed7 	.word	0x70000ed7
70000d48:	70000d6d 	.word	0x70000d6d
  {
  case 0x00:  /* HSI used as system clock source (default after reset) */
    sysclk = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
70000d4c:	4b73      	ldr	r3, [pc, #460]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000d4e:	681b      	ldr	r3, [r3, #0]
70000d50:	08db      	lsrs	r3, r3, #3
70000d52:	f003 0303 	and.w	r3, r3, #3
70000d56:	4a72      	ldr	r2, [pc, #456]	@ (70000f20 <SystemCoreClockUpdate+0x254>)
70000d58:	fa22 f303 	lsr.w	r3, r2, r3
70000d5c:	61fb      	str	r3, [r7, #28]
    break;
70000d5e:	e0c4      	b.n	70000eea <SystemCoreClockUpdate+0x21e>

  case 0x08:  /* CSI used as system clock source */
    sysclk = CSI_VALUE;
70000d60:	4b70      	ldr	r3, [pc, #448]	@ (70000f24 <SystemCoreClockUpdate+0x258>)
70000d62:	61fb      	str	r3, [r7, #28]
    break;
70000d64:	e0c1      	b.n	70000eea <SystemCoreClockUpdate+0x21e>

  case 0x10:  /* HSE used as system clock source */
    sysclk = HSE_VALUE;
70000d66:	4b70      	ldr	r3, [pc, #448]	@ (70000f28 <SystemCoreClockUpdate+0x25c>)
70000d68:	61fb      	str	r3, [r7, #28]
    break;
70000d6a:	e0be      	b.n	70000eea <SystemCoreClockUpdate+0x21e>

  case 0x18:  /* PLL1 used as system clock  source */
    /* PLL1_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL1_VCO / PLL1R
       */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
70000d6c:	4b6b      	ldr	r3, [pc, #428]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000d6e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70000d70:	f003 0303 	and.w	r3, r3, #3
70000d74:	613b      	str	r3, [r7, #16]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos)  ;
70000d76:	4b69      	ldr	r3, [pc, #420]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000d78:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70000d7a:	091b      	lsrs	r3, r3, #4
70000d7c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70000d80:	60fb      	str	r3, [r7, #12]
    if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) != 0U)
70000d82:	4b66      	ldr	r3, [pc, #408]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000d84:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70000d86:	f003 0301 	and.w	r3, r3, #1
70000d8a:	2b00      	cmp	r3, #0
70000d8c:	d00b      	beq.n	70000da6 <SystemCoreClockUpdate+0xda>
    {
      pllfracn = (float_t)(uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN)>> RCC_PLL1FRACR_FRACN_Pos));
70000d8e:	4b63      	ldr	r3, [pc, #396]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000d90:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
70000d92:	08db      	lsrs	r3, r3, #3
70000d94:	f3c3 030c 	ubfx	r3, r3, #0, #13
70000d98:	ee07 3a90 	vmov	s15, r3
70000d9c:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000da0:	edc7 7a06 	vstr	s15, [r7, #24]
70000da4:	e002      	b.n	70000dac <SystemCoreClockUpdate+0xe0>
    }
    else
    {
      pllfracn = (float_t)0U;
70000da6:	f04f 0300 	mov.w	r3, #0
70000daa:	61bb      	str	r3, [r7, #24]
    }

    if (pllm != 0U)
70000dac:	68fb      	ldr	r3, [r7, #12]
70000dae:	2b00      	cmp	r3, #0
70000db0:	f000 808e 	beq.w	70000ed0 <SystemCoreClockUpdate+0x204>
70000db4:	693b      	ldr	r3, [r7, #16]
70000db6:	2b01      	cmp	r3, #1
70000db8:	d024      	beq.n	70000e04 <SystemCoreClockUpdate+0x138>
70000dba:	693b      	ldr	r3, [r7, #16]
70000dbc:	2b02      	cmp	r3, #2
70000dbe:	d143      	bne.n	70000e48 <SystemCoreClockUpdate+0x17c>
    {
      switch (pllsource)
      {
      case 0x02:  /* HSE used as PLL1 clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
70000dc0:	68fb      	ldr	r3, [r7, #12]
70000dc2:	ee07 3a90 	vmov	s15, r3
70000dc6:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000dca:	eddf 6a58 	vldr	s13, [pc, #352]	@ 70000f2c <SystemCoreClockUpdate+0x260>
70000dce:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70000dd2:	4b52      	ldr	r3, [pc, #328]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000dd4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70000dd6:	f3c3 0308 	ubfx	r3, r3, #0, #9
70000dda:	ee07 3a90 	vmov	s15, r3
70000dde:	eef8 6a67 	vcvt.f32.u32	s13, s15
70000de2:	ed97 6a06 	vldr	s12, [r7, #24]
70000de6:	eddf 5a52 	vldr	s11, [pc, #328]	@ 70000f30 <SystemCoreClockUpdate+0x264>
70000dea:	eec6 7a25 	vdiv.f32	s15, s12, s11
70000dee:	ee76 7aa7 	vadd.f32	s15, s13, s15
70000df2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70000df6:	ee77 7aa6 	vadd.f32	s15, s15, s13
70000dfa:	ee67 7a27 	vmul.f32	s15, s14, s15
70000dfe:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
70000e02:	e04f      	b.n	70000ea4 <SystemCoreClockUpdate+0x1d8>

      case 0x01:  /* CSI used as PLL1 clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
70000e04:	68fb      	ldr	r3, [r7, #12]
70000e06:	ee07 3a90 	vmov	s15, r3
70000e0a:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000e0e:	eddf 6a49 	vldr	s13, [pc, #292]	@ 70000f34 <SystemCoreClockUpdate+0x268>
70000e12:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70000e16:	4b41      	ldr	r3, [pc, #260]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000e18:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70000e1a:	f3c3 0308 	ubfx	r3, r3, #0, #9
70000e1e:	ee07 3a90 	vmov	s15, r3
70000e22:	eef8 6a67 	vcvt.f32.u32	s13, s15
70000e26:	ed97 6a06 	vldr	s12, [r7, #24]
70000e2a:	eddf 5a41 	vldr	s11, [pc, #260]	@ 70000f30 <SystemCoreClockUpdate+0x264>
70000e2e:	eec6 7a25 	vdiv.f32	s15, s12, s11
70000e32:	ee76 7aa7 	vadd.f32	s15, s13, s15
70000e36:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70000e3a:	ee77 7aa6 	vadd.f32	s15, s15, s13
70000e3e:	ee67 7a27 	vmul.f32	s15, s14, s15
70000e42:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
70000e46:	e02d      	b.n	70000ea4 <SystemCoreClockUpdate+0x1d8>

      case 0x00:  /* HSI used as PLL1 clock source */
      default:
        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
70000e48:	4b34      	ldr	r3, [pc, #208]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000e4a:	681b      	ldr	r3, [r3, #0]
70000e4c:	08db      	lsrs	r3, r3, #3
70000e4e:	f003 0303 	and.w	r3, r3, #3
70000e52:	4a33      	ldr	r2, [pc, #204]	@ (70000f20 <SystemCoreClockUpdate+0x254>)
70000e54:	fa22 f303 	lsr.w	r3, r2, r3
70000e58:	60bb      	str	r3, [r7, #8]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
70000e5a:	68bb      	ldr	r3, [r7, #8]
70000e5c:	ee07 3a90 	vmov	s15, r3
70000e60:	eef8 6a67 	vcvt.f32.u32	s13, s15
70000e64:	68fb      	ldr	r3, [r7, #12]
70000e66:	ee07 3a90 	vmov	s15, r3
70000e6a:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000e6e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70000e72:	4b2a      	ldr	r3, [pc, #168]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000e74:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70000e76:	f3c3 0308 	ubfx	r3, r3, #0, #9
70000e7a:	ee07 3a90 	vmov	s15, r3
70000e7e:	eef8 6a67 	vcvt.f32.u32	s13, s15
70000e82:	ed97 6a06 	vldr	s12, [r7, #24]
70000e86:	eddf 5a2a 	vldr	s11, [pc, #168]	@ 70000f30 <SystemCoreClockUpdate+0x264>
70000e8a:	eec6 7a25 	vdiv.f32	s15, s12, s11
70000e8e:	ee76 7aa7 	vadd.f32	s15, s13, s15
70000e92:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70000e96:	ee77 7aa6 	vadd.f32	s15, s15, s13
70000e9a:	ee67 7a27 	vmul.f32	s15, s14, s15
70000e9e:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
70000ea2:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVP) >> RCC_PLL1DIVR1_DIVP_Pos) + 1U ) ;
70000ea4:	4b1d      	ldr	r3, [pc, #116]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000ea6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70000ea8:	0a5b      	lsrs	r3, r3, #9
70000eaa:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
70000eae:	3301      	adds	r3, #1
70000eb0:	607b      	str	r3, [r7, #4]
      sysclk =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
70000eb2:	687b      	ldr	r3, [r7, #4]
70000eb4:	ee07 3a90 	vmov	s15, r3
70000eb8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
70000ebc:	edd7 6a05 	vldr	s13, [r7, #20]
70000ec0:	eec6 7a87 	vdiv.f32	s15, s13, s14
70000ec4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
70000ec8:	ee17 3a90 	vmov	r3, s15
70000ecc:	61fb      	str	r3, [r7, #28]
    }
    else
    {
      sysclk = 0U;
    }
    break;
70000ece:	e00c      	b.n	70000eea <SystemCoreClockUpdate+0x21e>
      sysclk = 0U;
70000ed0:	2300      	movs	r3, #0
70000ed2:	61fb      	str	r3, [r7, #28]
    break;
70000ed4:	e009      	b.n	70000eea <SystemCoreClockUpdate+0x21e>

  default:  /* Unexpected, default to HSI used as system clock source (default after reset) */
    sysclk = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
70000ed6:	4b11      	ldr	r3, [pc, #68]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000ed8:	681b      	ldr	r3, [r3, #0]
70000eda:	08db      	lsrs	r3, r3, #3
70000edc:	f003 0303 	and.w	r3, r3, #3
70000ee0:	4a0f      	ldr	r2, [pc, #60]	@ (70000f20 <SystemCoreClockUpdate+0x254>)
70000ee2:	fa22 f303 	lsr.w	r3, r2, r3
70000ee6:	61fb      	str	r3, [r7, #28]
    break;
70000ee8:	bf00      	nop
  }

  /* system clock frequency : CM7 CPU frequency  */
  core_presc = (RCC->CDCFGR & RCC_CDCFGR_CPRE);
70000eea:	4b0c      	ldr	r3, [pc, #48]	@ (70000f1c <SystemCoreClockUpdate+0x250>)
70000eec:	699b      	ldr	r3, [r3, #24]
70000eee:	f003 030f 	and.w	r3, r3, #15
70000ef2:	603b      	str	r3, [r7, #0]
  if (core_presc >= 8U)
70000ef4:	683b      	ldr	r3, [r7, #0]
70000ef6:	2b07      	cmp	r3, #7
70000ef8:	d907      	bls.n	70000f0a <SystemCoreClockUpdate+0x23e>
  {
    SystemCoreClock = (sysclk >> (core_presc - RCC_CDCFGR_CPRE_3 + 1U));
70000efa:	683b      	ldr	r3, [r7, #0]
70000efc:	3b07      	subs	r3, #7
70000efe:	69fa      	ldr	r2, [r7, #28]
70000f00:	fa22 f303 	lsr.w	r3, r2, r3
70000f04:	4a0c      	ldr	r2, [pc, #48]	@ (70000f38 <SystemCoreClockUpdate+0x26c>)
70000f06:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SystemCoreClock = sysclk;
  }
}
70000f08:	e002      	b.n	70000f10 <SystemCoreClockUpdate+0x244>
    SystemCoreClock = sysclk;
70000f0a:	4a0b      	ldr	r2, [pc, #44]	@ (70000f38 <SystemCoreClockUpdate+0x26c>)
70000f0c:	69fb      	ldr	r3, [r7, #28]
70000f0e:	6013      	str	r3, [r2, #0]
}
70000f10:	bf00      	nop
70000f12:	3724      	adds	r7, #36	@ 0x24
70000f14:	46bd      	mov	sp, r7
70000f16:	f85d 7b04 	ldr.w	r7, [sp], #4
70000f1a:	4770      	bx	lr
70000f1c:	58024400 	.word	0x58024400
70000f20:	03d09000 	.word	0x03d09000
70000f24:	003d0900 	.word	0x003d0900
70000f28:	016e3600 	.word	0x016e3600
70000f2c:	4bb71b00 	.word	0x4bb71b00
70000f30:	46000000 	.word	0x46000000
70000f34:	4a742400 	.word	0x4a742400
70000f38:	24000000 	.word	0x24000000

70000f3c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
70000f3c:	480d      	ldr	r0, [pc, #52]	@ (70000f74 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
70000f3e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
70000f40:	f7ff feae 	bl	70000ca0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
70000f44:	480c      	ldr	r0, [pc, #48]	@ (70000f78 <LoopForever+0x6>)
  ldr r1, =_edata
70000f46:	490d      	ldr	r1, [pc, #52]	@ (70000f7c <LoopForever+0xa>)
  ldr r2, =_sidata
70000f48:	4a0d      	ldr	r2, [pc, #52]	@ (70000f80 <LoopForever+0xe>)
  movs r3, #0
70000f4a:	2300      	movs	r3, #0
  b LoopCopyDataInit
70000f4c:	e002      	b.n	70000f54 <LoopCopyDataInit>

70000f4e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
70000f4e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
70000f50:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
70000f52:	3304      	adds	r3, #4

70000f54 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
70000f54:	18c4      	adds	r4, r0, r3
  cmp r4, r1
70000f56:	428c      	cmp	r4, r1
  bcc CopyDataInit
70000f58:	d3f9      	bcc.n	70000f4e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
70000f5a:	4a0a      	ldr	r2, [pc, #40]	@ (70000f84 <LoopForever+0x12>)
  ldr r4, =_ebss
70000f5c:	4c0a      	ldr	r4, [pc, #40]	@ (70000f88 <LoopForever+0x16>)
  movs r3, #0
70000f5e:	2300      	movs	r3, #0
  b LoopFillZerobss
70000f60:	e001      	b.n	70000f66 <LoopFillZerobss>

70000f62 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
70000f62:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
70000f64:	3204      	adds	r2, #4

70000f66 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
70000f66:	42a2      	cmp	r2, r4
  bcc FillZerobss
70000f68:	d3fb      	bcc.n	70000f62 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
70000f6a:	f001 ff2f 	bl	70002dcc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
70000f6e:	f7ff fbd9 	bl	70000724 <main>

70000f72 <LoopForever>:

LoopForever:
  b LoopForever
70000f72:	e7fe      	b.n	70000f72 <LoopForever>
  ldr   r0, =_estack
70000f74:	20010000 	.word	0x20010000
  ldr r0, =_sdata
70000f78:	24000000 	.word	0x24000000
  ldr r1, =_edata
70000f7c:	24000030 	.word	0x24000030
  ldr r2, =_sidata
70000f80:	70002e5c 	.word	0x70002e5c
  ldr r2, =_sbss
70000f84:	24000030 	.word	0x24000030
  ldr r4, =_ebss
70000f88:	24001900 	.word	0x24001900

70000f8c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
70000f8c:	e7fe      	b.n	70000f8c <ADC1_2_IRQHandler>
	...

70000f90 <BSP_LED_Init>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
70000f90:	b580      	push	{r7, lr}
70000f92:	b08c      	sub	sp, #48	@ 0x30
70000f94:	af00      	add	r7, sp, #0
70000f96:	4603      	mov	r3, r0
70000f98:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
70000f9a:	2300      	movs	r3, #0
70000f9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  GPIO_InitTypeDef GPIO_Init = {0};
70000f9e:	f107 0318 	add.w	r3, r7, #24
70000fa2:	2200      	movs	r2, #0
70000fa4:	601a      	str	r2, [r3, #0]
70000fa6:	605a      	str	r2, [r3, #4]
70000fa8:	609a      	str	r2, [r3, #8]
70000faa:	60da      	str	r2, [r3, #12]
70000fac:	611a      	str	r2, [r3, #16]

  /* Enable the GPIO_LED Clock */
  if (Led == LD1)
70000fae:	79fb      	ldrb	r3, [r7, #7]
70000fb0:	2b00      	cmp	r3, #0
70000fb2:	d10d      	bne.n	70000fd0 <BSP_LED_Init+0x40>
  {
    LD1_GPIO_CLK_ENABLE();
70000fb4:	4b24      	ldr	r3, [pc, #144]	@ (70001048 <BSP_LED_Init+0xb8>)
70000fb6:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000fba:	4a23      	ldr	r2, [pc, #140]	@ (70001048 <BSP_LED_Init+0xb8>)
70000fbc:	f043 0308 	orr.w	r3, r3, #8
70000fc0:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000fc4:	4b20      	ldr	r3, [pc, #128]	@ (70001048 <BSP_LED_Init+0xb8>)
70000fc6:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000fca:	617b      	str	r3, [r7, #20]
70000fcc:	697b      	ldr	r3, [r7, #20]
70000fce:	e01d      	b.n	7000100c <BSP_LED_Init+0x7c>
  }
  else if (Led == LD2)
70000fd0:	79fb      	ldrb	r3, [r7, #7]
70000fd2:	2b01      	cmp	r3, #1
70000fd4:	d10d      	bne.n	70000ff2 <BSP_LED_Init+0x62>
  {
    LD2_GPIO_CLK_ENABLE();
70000fd6:	4b1c      	ldr	r3, [pc, #112]	@ (70001048 <BSP_LED_Init+0xb8>)
70000fd8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000fdc:	4a1a      	ldr	r2, [pc, #104]	@ (70001048 <BSP_LED_Init+0xb8>)
70000fde:	f043 0308 	orr.w	r3, r3, #8
70000fe2:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000fe6:	4b18      	ldr	r3, [pc, #96]	@ (70001048 <BSP_LED_Init+0xb8>)
70000fe8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000fec:	613b      	str	r3, [r7, #16]
70000fee:	693b      	ldr	r3, [r7, #16]
70000ff0:	e00c      	b.n	7000100c <BSP_LED_Init+0x7c>
  }
  else /* Led == LD3 */
  {
    LD3_GPIO_CLK_ENABLE();
70000ff2:	4b15      	ldr	r3, [pc, #84]	@ (70001048 <BSP_LED_Init+0xb8>)
70000ff4:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000ff8:	4a13      	ldr	r2, [pc, #76]	@ (70001048 <BSP_LED_Init+0xb8>)
70000ffa:	f043 0302 	orr.w	r3, r3, #2
70000ffe:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70001002:	4b11      	ldr	r3, [pc, #68]	@ (70001048 <BSP_LED_Init+0xb8>)
70001004:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70001008:	60fb      	str	r3, [r7, #12]
7000100a:	68fb      	ldr	r3, [r7, #12]
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
7000100c:	79fb      	ldrb	r3, [r7, #7]
7000100e:	4a0f      	ldr	r2, [pc, #60]	@ (7000104c <BSP_LED_Init+0xbc>)
70001010:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
70001014:	61bb      	str	r3, [r7, #24]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
70001016:	2301      	movs	r3, #1
70001018:	61fb      	str	r3, [r7, #28]
  GPIO_Init.Pull  = GPIO_PULLUP;
7000101a:	2301      	movs	r3, #1
7000101c:	623b      	str	r3, [r7, #32]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
7000101e:	2303      	movs	r3, #3
70001020:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
70001022:	79fb      	ldrb	r3, [r7, #7]
70001024:	4a0a      	ldr	r2, [pc, #40]	@ (70001050 <BSP_LED_Init+0xc0>)
70001026:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
7000102a:	f107 0218 	add.w	r2, r7, #24
7000102e:	4611      	mov	r1, r2
70001030:	4618      	mov	r0, r3
70001032:	f000 fc19 	bl	70001868 <HAL_GPIO_Init>

  /* By default, turn off LED */
  (void) BSP_LED_Off(Led);
70001036:	79fb      	ldrb	r3, [r7, #7]
70001038:	4618      	mov	r0, r3
7000103a:	f000 f80b 	bl	70001054 <BSP_LED_Off>
  return ret;
7000103e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
70001040:	4618      	mov	r0, r3
70001042:	3730      	adds	r7, #48	@ 0x30
70001044:	46bd      	mov	sp, r7
70001046:	bd80      	pop	{r7, pc}
70001048:	58024400 	.word	0x58024400
7000104c:	24000004 	.word	0x24000004
70001050:	2400000c 	.word	0x2400000c

70001054 <BSP_LED_Off>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
70001054:	b580      	push	{r7, lr}
70001056:	b082      	sub	sp, #8
70001058:	af00      	add	r7, sp, #0
7000105a:	4603      	mov	r3, r0
7000105c:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
7000105e:	79fb      	ldrb	r3, [r7, #7]
70001060:	4a07      	ldr	r2, [pc, #28]	@ (70001080 <BSP_LED_Off+0x2c>)
70001062:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
70001066:	79fb      	ldrb	r3, [r7, #7]
70001068:	4a06      	ldr	r2, [pc, #24]	@ (70001084 <BSP_LED_Off+0x30>)
7000106a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
7000106e:	2200      	movs	r2, #0
70001070:	4619      	mov	r1, r3
70001072:	f000 fd4f 	bl	70001b14 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
70001076:	2300      	movs	r3, #0
}
70001078:	4618      	mov	r0, r3
7000107a:	3708      	adds	r7, #8
7000107c:	46bd      	mov	sp, r7
7000107e:	bd80      	pop	{r7, pc}
70001080:	2400000c 	.word	0x2400000c
70001084:	24000004 	.word	0x24000004

70001088 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability
  * @retval BSP error code
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
70001088:	b580      	push	{r7, lr}
7000108a:	b08e      	sub	sp, #56	@ 0x38
7000108c:	af00      	add	r7, sp, #0
7000108e:	4603      	mov	r3, r0
70001090:	460a      	mov	r2, r1
70001092:	71fb      	strb	r3, [r7, #7]
70001094:	4613      	mov	r3, r2
70001096:	71bb      	strb	r3, [r7, #6]
  int32_t               status = BSP_ERROR_NONE;
70001098:	2300      	movs	r3, #0
7000109a:	637b      	str	r3, [r7, #52]	@ 0x34
  GPIO_InitTypeDef      GPIO_Init = {0};
7000109c:	f107 0320 	add.w	r3, r7, #32
700010a0:	2200      	movs	r2, #0
700010a2:	601a      	str	r2, [r3, #0]
700010a4:	605a      	str	r2, [r3, #4]
700010a6:	609a      	str	r2, [r3, #8]
700010a8:	60da      	str	r2, [r3, #12]
700010aa:	611a      	str	r2, [r3, #16]
  uint32_t              BSP_BUTTON_IT_PRIO[BUTTONn] = {BSP_BUTTON_USER_IT_PRIORITY};
700010ac:	230f      	movs	r3, #15
700010ae:	61fb      	str	r3, [r7, #28]
  uint32_t              BUTTON_EXTI_LINE[BUTTONn]   = {BUTTON_USER_EXTI_LINE};
700010b0:	4b45      	ldr	r3, [pc, #276]	@ (700011c8 <BSP_PB_Init+0x140>)
700010b2:	61bb      	str	r3, [r7, #24]
  BSP_EXTI_LineCallback ButtonCallback[BUTTONn]     = {BUTTON_USER_EXTI_Callback};
700010b4:	4b45      	ldr	r3, [pc, #276]	@ (700011cc <BSP_PB_Init+0x144>)
700010b6:	617b      	str	r3, [r7, #20]

  /* Enable the BUTTON clock */
  BUTTON_USER_GPIO_CLK_ENABLE();
700010b8:	4b45      	ldr	r3, [pc, #276]	@ (700011d0 <BSP_PB_Init+0x148>)
700010ba:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700010be:	4a44      	ldr	r2, [pc, #272]	@ (700011d0 <BSP_PB_Init+0x148>)
700010c0:	f043 0304 	orr.w	r3, r3, #4
700010c4:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
700010c8:	4b41      	ldr	r3, [pc, #260]	@ (700011d0 <BSP_PB_Init+0x148>)
700010ca:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700010ce:	613b      	str	r3, [r7, #16]
700010d0:	693b      	ldr	r3, [r7, #16]

  GPIO_Init.Pin   = BUTTON_PIN[Button];
700010d2:	79fb      	ldrb	r3, [r7, #7]
700010d4:	4a3f      	ldr	r2, [pc, #252]	@ (700011d4 <BSP_PB_Init+0x14c>)
700010d6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700010da:	623b      	str	r3, [r7, #32]
  GPIO_Init.Pull  = GPIO_PULLUP;
700010dc:	2301      	movs	r3, #1
700010de:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_Init.Speed = GPIO_SPEED_FREQ_LOW;
700010e0:	2300      	movs	r3, #0
700010e2:	62fb      	str	r3, [r7, #44]	@ 0x2c

  if (ButtonMode == BUTTON_MODE_GPIO)
700010e4:	79bb      	ldrb	r3, [r7, #6]
700010e6:	2b00      	cmp	r3, #0
700010e8:	d10c      	bne.n	70001104 <BSP_PB_Init+0x7c>
  {
    /* Configure Button pin as input */
    GPIO_Init.Mode = GPIO_MODE_INPUT;
700010ea:	2300      	movs	r3, #0
700010ec:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
700010ee:	79fb      	ldrb	r3, [r7, #7]
700010f0:	4a39      	ldr	r2, [pc, #228]	@ (700011d8 <BSP_PB_Init+0x150>)
700010f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
700010f6:	f107 0220 	add.w	r2, r7, #32
700010fa:	4611      	mov	r1, r2
700010fc:	4618      	mov	r0, r3
700010fe:	f000 fbb3 	bl	70001868 <HAL_GPIO_Init>
70001102:	e058      	b.n	700011b6 <BSP_PB_Init+0x12e>
  }
  else /* ButtonMode == BUTTON_MODE_EXTI */
  {
    /* Enable SBS clock */
    __HAL_RCC_SBS_CLK_ENABLE();
70001104:	4b32      	ldr	r3, [pc, #200]	@ (700011d0 <BSP_PB_Init+0x148>)
70001106:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
7000110a:	4a31      	ldr	r2, [pc, #196]	@ (700011d0 <BSP_PB_Init+0x148>)
7000110c:	f043 0302 	orr.w	r3, r3, #2
70001110:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
70001114:	4b2e      	ldr	r3, [pc, #184]	@ (700011d0 <BSP_PB_Init+0x148>)
70001116:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
7000111a:	60fb      	str	r3, [r7, #12]
7000111c:	68fb      	ldr	r3, [r7, #12]

    /* Configure Button pin as input with External interrupt */
    GPIO_Init.Mode = GPIO_MODE_IT_FALLING;
7000111e:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
70001122:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
70001124:	79fb      	ldrb	r3, [r7, #7]
70001126:	4a2c      	ldr	r2, [pc, #176]	@ (700011d8 <BSP_PB_Init+0x150>)
70001128:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
7000112c:	f107 0220 	add.w	r2, r7, #32
70001130:	4611      	mov	r1, r2
70001132:	4618      	mov	r0, r3
70001134:	f000 fb98 	bl	70001868 <HAL_GPIO_Init>

    if (HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]) == HAL_OK)
70001138:	79fb      	ldrb	r3, [r7, #7]
7000113a:	00db      	lsls	r3, r3, #3
7000113c:	4a27      	ldr	r2, [pc, #156]	@ (700011dc <BSP_PB_Init+0x154>)
7000113e:	441a      	add	r2, r3
70001140:	79fb      	ldrb	r3, [r7, #7]
70001142:	009b      	lsls	r3, r3, #2
70001144:	3338      	adds	r3, #56	@ 0x38
70001146:	443b      	add	r3, r7
70001148:	f853 3c20 	ldr.w	r3, [r3, #-32]
7000114c:	4619      	mov	r1, r3
7000114e:	4610      	mov	r0, r2
70001150:	f000 fb45 	bl	700017de <HAL_EXTI_GetHandle>
70001154:	4603      	mov	r3, r0
70001156:	2b00      	cmp	r3, #0
70001158:	d12a      	bne.n	700011b0 <BSP_PB_Init+0x128>
    {
      if (HAL_EXTI_RegisterCallback(&hpb_exti[Button], HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]) == HAL_OK)
7000115a:	79fb      	ldrb	r3, [r7, #7]
7000115c:	00db      	lsls	r3, r3, #3
7000115e:	4a1f      	ldr	r2, [pc, #124]	@ (700011dc <BSP_PB_Init+0x154>)
70001160:	1898      	adds	r0, r3, r2
70001162:	79fb      	ldrb	r3, [r7, #7]
70001164:	009b      	lsls	r3, r3, #2
70001166:	3338      	adds	r3, #56	@ 0x38
70001168:	443b      	add	r3, r7
7000116a:	f853 3c24 	ldr.w	r3, [r3, #-36]
7000116e:	461a      	mov	r2, r3
70001170:	2100      	movs	r1, #0
70001172:	f000 fb1a 	bl	700017aa <HAL_EXTI_RegisterCallback>
70001176:	4603      	mov	r3, r0
70001178:	2b00      	cmp	r3, #0
7000117a:	d115      	bne.n	700011a8 <BSP_PB_Init+0x120>
      {
        /* Enable and set Button EXTI Interrupt to the lowest priority */
        HAL_NVIC_SetPriority(BUTTON_IRQn[Button], BSP_BUTTON_IT_PRIO[Button], 0x00);
7000117c:	79fb      	ldrb	r3, [r7, #7]
7000117e:	4a18      	ldr	r2, [pc, #96]	@ (700011e0 <BSP_PB_Init+0x158>)
70001180:	f932 0013 	ldrsh.w	r0, [r2, r3, lsl #1]
70001184:	79fb      	ldrb	r3, [r7, #7]
70001186:	009b      	lsls	r3, r3, #2
70001188:	3338      	adds	r3, #56	@ 0x38
7000118a:	443b      	add	r3, r7
7000118c:	f853 3c1c 	ldr.w	r3, [r3, #-28]
70001190:	2200      	movs	r2, #0
70001192:	4619      	mov	r1, r3
70001194:	f000 fad5 	bl	70001742 <HAL_NVIC_SetPriority>
        HAL_NVIC_EnableIRQ(BUTTON_IRQn[Button]);
70001198:	79fb      	ldrb	r3, [r7, #7]
7000119a:	4a11      	ldr	r2, [pc, #68]	@ (700011e0 <BSP_PB_Init+0x158>)
7000119c:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
700011a0:	4618      	mov	r0, r3
700011a2:	f000 fae8 	bl	70001776 <HAL_NVIC_EnableIRQ>
700011a6:	e006      	b.n	700011b6 <BSP_PB_Init+0x12e>
      }
      else
      {
        status = BSP_ERROR_PERIPH_FAILURE;
700011a8:	f06f 0303 	mvn.w	r3, #3
700011ac:	637b      	str	r3, [r7, #52]	@ 0x34
700011ae:	e002      	b.n	700011b6 <BSP_PB_Init+0x12e>
      }
    }
    else
    {
      status = BSP_ERROR_PERIPH_FAILURE;
700011b0:	f06f 0303 	mvn.w	r3, #3
700011b4:	637b      	str	r3, [r7, #52]	@ 0x34
    }
  }

  /* Delay to avoid that possible signal rebound is taken as button release */
  HAL_Delay(1);
700011b6:	2001      	movs	r0, #1
700011b8:	f000 f9c4 	bl	70001544 <HAL_Delay>

  return status;
700011bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
700011be:	4618      	mov	r0, r3
700011c0:	3738      	adds	r7, #56	@ 0x38
700011c2:	46bd      	mov	sp, r7
700011c4:	bd80      	pop	{r7, pc}
700011c6:	bf00      	nop
700011c8:	1600000d 	.word	0x1600000d
700011cc:	700012c1 	.word	0x700012c1
700011d0:	58024400 	.word	0x58024400
700011d4:	24000018 	.word	0x24000018
700011d8:	2400001c 	.word	0x2400001c
700011dc:	240018f4 	.word	0x240018f4
700011e0:	24000020 	.word	0x24000020

700011e4 <BSP_PB_Callback>:
  * @brief  BSP Push Button callback
  * @param  Button Specifies the pin connected EXTI line
  * @retval None.
  */
__weak void BSP_PB_Callback(Button_TypeDef Button)
{
700011e4:	b480      	push	{r7}
700011e6:	b083      	sub	sp, #12
700011e8:	af00      	add	r7, sp, #0
700011ea:	4603      	mov	r3, r0
700011ec:	71fb      	strb	r3, [r7, #7]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
700011ee:	bf00      	nop
700011f0:	370c      	adds	r7, #12
700011f2:	46bd      	mov	sp, r7
700011f4:	f85d 7b04 	ldr.w	r7, [sp], #4
700011f8:	4770      	bx	lr
	...

700011fc <BSP_PB_IRQHandler>:
  *   This parameter should be:
  *     @arg BUTTON_USER
  * @retval None.
  */
void BSP_PB_IRQHandler(Button_TypeDef Button)
{
700011fc:	b580      	push	{r7, lr}
700011fe:	b082      	sub	sp, #8
70001200:	af00      	add	r7, sp, #0
70001202:	4603      	mov	r3, r0
70001204:	71fb      	strb	r3, [r7, #7]
  HAL_EXTI_IRQHandler(&hpb_exti[Button]);
70001206:	79fb      	ldrb	r3, [r7, #7]
70001208:	00db      	lsls	r3, r3, #3
7000120a:	4a04      	ldr	r2, [pc, #16]	@ (7000121c <BSP_PB_IRQHandler+0x20>)
7000120c:	4413      	add	r3, r2
7000120e:	4618      	mov	r0, r3
70001210:	f000 fafa 	bl	70001808 <HAL_EXTI_IRQHandler>
}
70001214:	bf00      	nop
70001216:	3708      	adds	r7, #8
70001218:	46bd      	mov	sp, r7
7000121a:	bd80      	pop	{r7, pc}
7000121c:	240018f4 	.word	0x240018f4

70001220 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a COM_InitTypeDef structure that contains the
  *                configuration information for the specified COM peripheral.
  * @retval BSP error code
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
70001220:	b580      	push	{r7, lr}
70001222:	b084      	sub	sp, #16
70001224:	af00      	add	r7, sp, #0
70001226:	4603      	mov	r3, r0
70001228:	6039      	str	r1, [r7, #0]
7000122a:	71fb      	strb	r3, [r7, #7]
  int32_t status = BSP_ERROR_NONE;
7000122c:	2300      	movs	r3, #0
7000122e:	60fb      	str	r3, [r7, #12]

  if (COM_Init == NULL)
70001230:	683b      	ldr	r3, [r7, #0]
70001232:	2b00      	cmp	r3, #0
70001234:	d103      	bne.n	7000123e <BSP_COM_Init+0x1e>
  {
    status = BSP_ERROR_WRONG_PARAM;
70001236:	f06f 0301 	mvn.w	r3, #1
7000123a:	60fb      	str	r3, [r7, #12]
7000123c:	e037      	b.n	700012ae <BSP_COM_Init+0x8e>
  }
  else
  {
    /* Initialize COM instance */
    hcom_uart[COM].Instance = COM_UART[COM];
7000123e:	79fa      	ldrb	r2, [r7, #7]
70001240:	79fb      	ldrb	r3, [r7, #7]
70001242:	491d      	ldr	r1, [pc, #116]	@ (700012b8 <BSP_COM_Init+0x98>)
70001244:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
70001248:	491c      	ldr	r1, [pc, #112]	@ (700012bc <BSP_COM_Init+0x9c>)
7000124a:	2094      	movs	r0, #148	@ 0x94
7000124c:	fb00 f303 	mul.w	r3, r0, r3
70001250:	440b      	add	r3, r1
70001252:	601a      	str	r2, [r3, #0]

#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    UART_MspInit(&hcom_uart[COM]);
70001254:	79fb      	ldrb	r3, [r7, #7]
70001256:	2294      	movs	r2, #148	@ 0x94
70001258:	fb02 f303 	mul.w	r3, r2, r3
7000125c:	4a17      	ldr	r2, [pc, #92]	@ (700012bc <BSP_COM_Init+0x9c>)
7000125e:	4413      	add	r3, r2
70001260:	4618      	mov	r0, r3
70001262:	f000 f869 	bl	70001338 <UART_MspInit>
    }

    if (status == BSP_ERROR_NONE)
    {
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      if (COM == COM1)
70001266:	79fb      	ldrb	r3, [r7, #7]
70001268:	2b00      	cmp	r3, #0
7000126a:	d110      	bne.n	7000128e <BSP_COM_Init+0x6e>
      {
        if (MX_USART3_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
7000126c:	79fb      	ldrb	r3, [r7, #7]
7000126e:	2294      	movs	r2, #148	@ 0x94
70001270:	fb02 f303 	mul.w	r3, r2, r3
70001274:	4a11      	ldr	r2, [pc, #68]	@ (700012bc <BSP_COM_Init+0x9c>)
70001276:	4413      	add	r3, r2
70001278:	6839      	ldr	r1, [r7, #0]
7000127a:	4618      	mov	r0, r3
7000127c:	f000 f828 	bl	700012d0 <MX_USART3_Init>
70001280:	4603      	mov	r3, r0
70001282:	2b00      	cmp	r3, #0
70001284:	d013      	beq.n	700012ae <BSP_COM_Init+0x8e>
        {
          status = BSP_ERROR_PERIPH_FAILURE;
70001286:	f06f 0303 	mvn.w	r3, #3
7000128a:	60fb      	str	r3, [r7, #12]
7000128c:	e00f      	b.n	700012ae <BSP_COM_Init+0x8e>
        }
      }
      else /* COM = COM2 */
      {
        if (MX_USART3_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
7000128e:	79fb      	ldrb	r3, [r7, #7]
70001290:	2294      	movs	r2, #148	@ 0x94
70001292:	fb02 f303 	mul.w	r3, r2, r3
70001296:	4a09      	ldr	r2, [pc, #36]	@ (700012bc <BSP_COM_Init+0x9c>)
70001298:	4413      	add	r3, r2
7000129a:	6839      	ldr	r1, [r7, #0]
7000129c:	4618      	mov	r0, r3
7000129e:	f000 f817 	bl	700012d0 <MX_USART3_Init>
700012a2:	4603      	mov	r3, r0
700012a4:	2b00      	cmp	r3, #0
700012a6:	d002      	beq.n	700012ae <BSP_COM_Init+0x8e>
        {
          status = BSP_ERROR_PERIPH_FAILURE;
700012a8:	f06f 0303 	mvn.w	r3, #3
700012ac:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    }
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }

  return status;
700012ae:	68fb      	ldr	r3, [r7, #12]
}
700012b0:	4618      	mov	r0, r3
700012b2:	3710      	adds	r7, #16
700012b4:	46bd      	mov	sp, r7
700012b6:	bd80      	pop	{r7, pc}
700012b8:	24000024 	.word	0x24000024
700012bc:	24001860 	.word	0x24001860

700012c0 <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  User EXTI line detection callbacks.
  * @retval None
  */
static void BUTTON_USER_EXTI_Callback(void)
{
700012c0:	b580      	push	{r7, lr}
700012c2:	af00      	add	r7, sp, #0
  BSP_PB_Callback(BUTTON_USER);
700012c4:	2000      	movs	r0, #0
700012c6:	f7ff ff8d 	bl	700011e4 <BSP_PB_Callback>
}
700012ca:	bf00      	nop
700012cc:	bd80      	pop	{r7, pc}
	...

700012d0 <MX_USART3_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART3_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
700012d0:	b580      	push	{r7, lr}
700012d2:	b082      	sub	sp, #8
700012d4:	af00      	add	r7, sp, #0
700012d6:	6078      	str	r0, [r7, #4]
700012d8:	6039      	str	r1, [r7, #0]
  /* USART configuration */
  huart->Instance          = COM_UART[COM1];
700012da:	4b16      	ldr	r3, [pc, #88]	@ (70001334 <MX_USART3_Init+0x64>)
700012dc:	681a      	ldr	r2, [r3, #0]
700012de:	687b      	ldr	r3, [r7, #4]
700012e0:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
700012e2:	683b      	ldr	r3, [r7, #0]
700012e4:	681a      	ldr	r2, [r3, #0]
700012e6:	687b      	ldr	r3, [r7, #4]
700012e8:	605a      	str	r2, [r3, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
700012ea:	687b      	ldr	r3, [r7, #4]
700012ec:	220c      	movs	r2, #12
700012ee:	615a      	str	r2, [r3, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
700012f0:	683b      	ldr	r3, [r7, #0]
700012f2:	895b      	ldrh	r3, [r3, #10]
700012f4:	461a      	mov	r2, r3
700012f6:	687b      	ldr	r3, [r7, #4]
700012f8:	611a      	str	r2, [r3, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
700012fa:	683b      	ldr	r3, [r7, #0]
700012fc:	685a      	ldr	r2, [r3, #4]
700012fe:	687b      	ldr	r3, [r7, #4]
70001300:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
70001302:	683b      	ldr	r3, [r7, #0]
70001304:	891b      	ldrh	r3, [r3, #8]
70001306:	461a      	mov	r2, r3
70001308:	687b      	ldr	r3, [r7, #4]
7000130a:	60da      	str	r2, [r3, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
7000130c:	683b      	ldr	r3, [r7, #0]
7000130e:	899b      	ldrh	r3, [r3, #12]
70001310:	461a      	mov	r2, r3
70001312:	687b      	ldr	r3, [r7, #4]
70001314:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
70001316:	687b      	ldr	r3, [r7, #4]
70001318:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
7000131c:	61da      	str	r2, [r3, #28]
  huart->Init.ClockPrescaler     = UART_PRESCALER_DIV1;
7000131e:	687b      	ldr	r3, [r7, #4]
70001320:	2200      	movs	r2, #0
70001322:	625a      	str	r2, [r3, #36]	@ 0x24
  return HAL_UART_Init(huart);
70001324:	6878      	ldr	r0, [r7, #4]
70001326:	f000 ff41 	bl	700021ac <HAL_UART_Init>
7000132a:	4603      	mov	r3, r0
}
7000132c:	4618      	mov	r0, r3
7000132e:	3708      	adds	r7, #8
70001330:	46bd      	mov	sp, r7
70001332:	bd80      	pop	{r7, pc}
70001334:	24000024 	.word	0x24000024

70001338 <UART_MspInit>:
  * @brief  Initialize UART MSP.
  * @param  huart UART handle.
  * @retval None.
  */
static void UART_MspInit(const UART_HandleTypeDef *huart)
{
70001338:	b580      	push	{r7, lr}
7000133a:	b092      	sub	sp, #72	@ 0x48
7000133c:	af00      	add	r7, sp, #0
7000133e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_Init = {0};
70001340:	f107 0330 	add.w	r3, r7, #48	@ 0x30
70001344:	2200      	movs	r2, #0
70001346:	601a      	str	r2, [r3, #0]
70001348:	605a      	str	r2, [r3, #4]
7000134a:	609a      	str	r2, [r3, #8]
7000134c:	60da      	str	r2, [r3, #12]
7000134e:	611a      	str	r2, [r3, #16]
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT};
70001350:	4b3f      	ldr	r3, [pc, #252]	@ (70001450 <UART_MspInit+0x118>)
70001352:	62fb      	str	r3, [r7, #44]	@ 0x2c
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT};
70001354:	4b3e      	ldr	r3, [pc, #248]	@ (70001450 <UART_MspInit+0x118>)
70001356:	62bb      	str	r3, [r7, #40]	@ 0x28
  const uint16_t   COM_TX_PIN[COMn]  = {COM1_TX_PIN};
70001358:	f44f 7380 	mov.w	r3, #256	@ 0x100
7000135c:	84bb      	strh	r3, [r7, #36]	@ 0x24
  const uint16_t   COM_RX_PIN[COMn]  = {COM1_RX_PIN};
7000135e:	f44f 7300 	mov.w	r3, #512	@ 0x200
70001362:	843b      	strh	r3, [r7, #32]
  const uint8_t    COM_TX_AF[COMn]   = {COM1_TX_AF};
70001364:	2307      	movs	r3, #7
70001366:	773b      	strb	r3, [r7, #28]
  const uint8_t    COM_RX_AF[COMn]   = {COM1_RX_AF};
70001368:	2307      	movs	r3, #7
7000136a:	763b      	strb	r3, [r7, #24]
  COM_TypeDef      COM;

  /* Get COM according instance */
  if (huart->Instance == COM1_UART)
7000136c:	687b      	ldr	r3, [r7, #4]
7000136e:	681b      	ldr	r3, [r3, #0]
70001370:	4a38      	ldr	r2, [pc, #224]	@ (70001454 <UART_MspInit+0x11c>)
70001372:	4293      	cmp	r3, r2
70001374:	d168      	bne.n	70001448 <UART_MspInit+0x110>
  {
    COM = COM1;
70001376:	2300      	movs	r3, #0
70001378:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    /* Enable COM and GPIO clocks */
    COM1_TX_GPIO_CLK_ENABLE();
7000137c:	4b36      	ldr	r3, [pc, #216]	@ (70001458 <UART_MspInit+0x120>)
7000137e:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70001382:	4a35      	ldr	r2, [pc, #212]	@ (70001458 <UART_MspInit+0x120>)
70001384:	f043 0308 	orr.w	r3, r3, #8
70001388:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
7000138c:	4b32      	ldr	r3, [pc, #200]	@ (70001458 <UART_MspInit+0x120>)
7000138e:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70001392:	617b      	str	r3, [r7, #20]
70001394:	697b      	ldr	r3, [r7, #20]
    COM1_RX_GPIO_CLK_ENABLE();
70001396:	4b30      	ldr	r3, [pc, #192]	@ (70001458 <UART_MspInit+0x120>)
70001398:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000139c:	4a2e      	ldr	r2, [pc, #184]	@ (70001458 <UART_MspInit+0x120>)
7000139e:	f043 0308 	orr.w	r3, r3, #8
700013a2:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
700013a6:	4b2c      	ldr	r3, [pc, #176]	@ (70001458 <UART_MspInit+0x120>)
700013a8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700013ac:	613b      	str	r3, [r7, #16]
700013ae:	693b      	ldr	r3, [r7, #16]
    COM1_CLK_ENABLE();
700013b0:	4b29      	ldr	r3, [pc, #164]	@ (70001458 <UART_MspInit+0x120>)
700013b2:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
700013b6:	4a28      	ldr	r2, [pc, #160]	@ (70001458 <UART_MspInit+0x120>)
700013b8:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
700013bc:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
700013c0:	4b25      	ldr	r3, [pc, #148]	@ (70001458 <UART_MspInit+0x120>)
700013c2:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
700013c6:	60fb      	str	r3, [r7, #12]
700013c8:	68fb      	ldr	r3, [r7, #12]
  {
    return;
  }

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM_TX_PIN[COM];
700013ca:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
700013ce:	005b      	lsls	r3, r3, #1
700013d0:	3348      	adds	r3, #72	@ 0x48
700013d2:	443b      	add	r3, r7
700013d4:	f833 3c24 	ldrh.w	r3, [r3, #-36]
700013d8:	633b      	str	r3, [r7, #48]	@ 0x30
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
700013da:	2302      	movs	r3, #2
700013dc:	637b      	str	r3, [r7, #52]	@ 0x34
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
700013de:	2302      	movs	r3, #2
700013e0:	63fb      	str	r3, [r7, #60]	@ 0x3c
  GPIO_Init.Pull      = GPIO_PULLUP;
700013e2:	2301      	movs	r3, #1
700013e4:	63bb      	str	r3, [r7, #56]	@ 0x38
  GPIO_Init.Alternate = COM_TX_AF[COM];
700013e6:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
700013ea:	3348      	adds	r3, #72	@ 0x48
700013ec:	443b      	add	r3, r7
700013ee:	f813 3c2c 	ldrb.w	r3, [r3, #-44]
700013f2:	643b      	str	r3, [r7, #64]	@ 0x40
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
700013f4:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
700013f8:	009b      	lsls	r3, r3, #2
700013fa:	3348      	adds	r3, #72	@ 0x48
700013fc:	443b      	add	r3, r7
700013fe:	f853 3c1c 	ldr.w	r3, [r3, #-28]
70001402:	f107 0230 	add.w	r2, r7, #48	@ 0x30
70001406:	4611      	mov	r1, r2
70001408:	4618      	mov	r0, r3
7000140a:	f000 fa2d 	bl	70001868 <HAL_GPIO_Init>

  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM_RX_PIN[COM];
7000140e:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
70001412:	005b      	lsls	r3, r3, #1
70001414:	3348      	adds	r3, #72	@ 0x48
70001416:	443b      	add	r3, r7
70001418:	f833 3c28 	ldrh.w	r3, [r3, #-40]
7000141c:	633b      	str	r3, [r7, #48]	@ 0x30
  GPIO_Init.Alternate = COM_RX_AF[COM];
7000141e:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
70001422:	3348      	adds	r3, #72	@ 0x48
70001424:	443b      	add	r3, r7
70001426:	f813 3c30 	ldrb.w	r3, [r3, #-48]
7000142a:	643b      	str	r3, [r7, #64]	@ 0x40
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
7000142c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
70001430:	009b      	lsls	r3, r3, #2
70001432:	3348      	adds	r3, #72	@ 0x48
70001434:	443b      	add	r3, r7
70001436:	f853 3c20 	ldr.w	r3, [r3, #-32]
7000143a:	f107 0230 	add.w	r2, r7, #48	@ 0x30
7000143e:	4611      	mov	r1, r2
70001440:	4618      	mov	r0, r3
70001442:	f000 fa11 	bl	70001868 <HAL_GPIO_Init>
70001446:	e000      	b.n	7000144a <UART_MspInit+0x112>
    return;
70001448:	bf00      	nop
}
7000144a:	3748      	adds	r7, #72	@ 0x48
7000144c:	46bd      	mov	sp, r7
7000144e:	bd80      	pop	{r7, pc}
70001450:	58020c00 	.word	0x58020c00
70001454:	40004800 	.word	0x40004800
70001458:	58024400 	.word	0x58024400

7000145c <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
7000145c:	b580      	push	{r7, lr}
7000145e:	b082      	sub	sp, #8
70001460:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
70001462:	2300      	movs	r3, #0
70001464:	71fb      	strb	r3, [r7, #7]

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
70001466:	2003      	movs	r0, #3
70001468:	f000 f960 	bl	7000172c <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
7000146c:	200f      	movs	r0, #15
7000146e:	f000 f80d 	bl	7000148c <HAL_InitTick>
70001472:	4603      	mov	r3, r0
70001474:	2b00      	cmp	r3, #0
70001476:	d002      	beq.n	7000147e <HAL_Init+0x22>
  {
    status = HAL_ERROR;
70001478:	2301      	movs	r3, #1
7000147a:	71fb      	strb	r3, [r7, #7]
7000147c:	e001      	b.n	70001482 <HAL_Init+0x26>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
7000147e:	f7ff fbd1 	bl	70000c24 <HAL_MspInit>
  }

  /* Return function status */
  return status;
70001482:	79fb      	ldrb	r3, [r7, #7]
}
70001484:	4618      	mov	r0, r3
70001486:	3708      	adds	r7, #8
70001488:	46bd      	mov	sp, r7
7000148a:	bd80      	pop	{r7, pc}

7000148c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
7000148c:	b580      	push	{r7, lr}
7000148e:	b084      	sub	sp, #16
70001490:	af00      	add	r7, sp, #0
70001492:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
70001494:	2300      	movs	r3, #0
70001496:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
70001498:	4b17      	ldr	r3, [pc, #92]	@ (700014f8 <HAL_InitTick+0x6c>)
7000149a:	781b      	ldrb	r3, [r3, #0]
7000149c:	2b00      	cmp	r3, #0
7000149e:	d023      	beq.n	700014e8 <HAL_InitTick+0x5c>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
700014a0:	4b16      	ldr	r3, [pc, #88]	@ (700014fc <HAL_InitTick+0x70>)
700014a2:	681a      	ldr	r2, [r3, #0]
700014a4:	4b14      	ldr	r3, [pc, #80]	@ (700014f8 <HAL_InitTick+0x6c>)
700014a6:	781b      	ldrb	r3, [r3, #0]
700014a8:	4619      	mov	r1, r3
700014aa:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
700014ae:	fbb3 f3f1 	udiv	r3, r3, r1
700014b2:	fbb2 f3f3 	udiv	r3, r2, r3
700014b6:	4618      	mov	r0, r3
700014b8:	f000 f96b 	bl	70001792 <HAL_SYSTICK_Config>
700014bc:	4603      	mov	r3, r0
700014be:	2b00      	cmp	r3, #0
700014c0:	d10f      	bne.n	700014e2 <HAL_InitTick+0x56>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
700014c2:	687b      	ldr	r3, [r7, #4]
700014c4:	2b0f      	cmp	r3, #15
700014c6:	d809      	bhi.n	700014dc <HAL_InitTick+0x50>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
700014c8:	2200      	movs	r2, #0
700014ca:	6879      	ldr	r1, [r7, #4]
700014cc:	f04f 30ff 	mov.w	r0, #4294967295
700014d0:	f000 f937 	bl	70001742 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
700014d4:	4a0a      	ldr	r2, [pc, #40]	@ (70001500 <HAL_InitTick+0x74>)
700014d6:	687b      	ldr	r3, [r7, #4]
700014d8:	6013      	str	r3, [r2, #0]
700014da:	e007      	b.n	700014ec <HAL_InitTick+0x60>
      }
      else
      {
        status = HAL_ERROR;
700014dc:	2301      	movs	r3, #1
700014de:	73fb      	strb	r3, [r7, #15]
700014e0:	e004      	b.n	700014ec <HAL_InitTick+0x60>
      }
    }
    else
    {
      status = HAL_ERROR;
700014e2:	2301      	movs	r3, #1
700014e4:	73fb      	strb	r3, [r7, #15]
700014e6:	e001      	b.n	700014ec <HAL_InitTick+0x60>
    }
  }
  else
  {
    status = HAL_ERROR;
700014e8:	2301      	movs	r3, #1
700014ea:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
700014ec:	7bfb      	ldrb	r3, [r7, #15]
}
700014ee:	4618      	mov	r0, r3
700014f0:	3710      	adds	r7, #16
700014f2:	46bd      	mov	sp, r7
700014f4:	bd80      	pop	{r7, pc}
700014f6:	bf00      	nop
700014f8:	2400002c 	.word	0x2400002c
700014fc:	24000000 	.word	0x24000000
70001500:	24000028 	.word	0x24000028

70001504 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
70001504:	b480      	push	{r7}
70001506:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
70001508:	4b06      	ldr	r3, [pc, #24]	@ (70001524 <HAL_IncTick+0x20>)
7000150a:	781b      	ldrb	r3, [r3, #0]
7000150c:	461a      	mov	r2, r3
7000150e:	4b06      	ldr	r3, [pc, #24]	@ (70001528 <HAL_IncTick+0x24>)
70001510:	681b      	ldr	r3, [r3, #0]
70001512:	4413      	add	r3, r2
70001514:	4a04      	ldr	r2, [pc, #16]	@ (70001528 <HAL_IncTick+0x24>)
70001516:	6013      	str	r3, [r2, #0]
}
70001518:	bf00      	nop
7000151a:	46bd      	mov	sp, r7
7000151c:	f85d 7b04 	ldr.w	r7, [sp], #4
70001520:	4770      	bx	lr
70001522:	bf00      	nop
70001524:	2400002c 	.word	0x2400002c
70001528:	240018fc 	.word	0x240018fc

7000152c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
7000152c:	b480      	push	{r7}
7000152e:	af00      	add	r7, sp, #0
  return uwTick;
70001530:	4b03      	ldr	r3, [pc, #12]	@ (70001540 <HAL_GetTick+0x14>)
70001532:	681b      	ldr	r3, [r3, #0]
}
70001534:	4618      	mov	r0, r3
70001536:	46bd      	mov	sp, r7
70001538:	f85d 7b04 	ldr.w	r7, [sp], #4
7000153c:	4770      	bx	lr
7000153e:	bf00      	nop
70001540:	240018fc 	.word	0x240018fc

70001544 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
70001544:	b580      	push	{r7, lr}
70001546:	b084      	sub	sp, #16
70001548:	af00      	add	r7, sp, #0
7000154a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
7000154c:	f7ff ffee 	bl	7000152c <HAL_GetTick>
70001550:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
70001552:	687b      	ldr	r3, [r7, #4]
70001554:	60fb      	str	r3, [r7, #12]

  /* Add a period to ensure minimum wait */
  if (wait < HAL_MAX_DELAY)
70001556:	68fb      	ldr	r3, [r7, #12]
70001558:	f1b3 3fff 	cmp.w	r3, #4294967295
7000155c:	d005      	beq.n	7000156a <HAL_Delay+0x26>
  {
    wait += (uint32_t)uwTickFreq;
7000155e:	4b0a      	ldr	r3, [pc, #40]	@ (70001588 <HAL_Delay+0x44>)
70001560:	781b      	ldrb	r3, [r3, #0]
70001562:	461a      	mov	r2, r3
70001564:	68fb      	ldr	r3, [r7, #12]
70001566:	4413      	add	r3, r2
70001568:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
7000156a:	bf00      	nop
7000156c:	f7ff ffde 	bl	7000152c <HAL_GetTick>
70001570:	4602      	mov	r2, r0
70001572:	68bb      	ldr	r3, [r7, #8]
70001574:	1ad3      	subs	r3, r2, r3
70001576:	68fa      	ldr	r2, [r7, #12]
70001578:	429a      	cmp	r2, r3
7000157a:	d8f7      	bhi.n	7000156c <HAL_Delay+0x28>
  {
  }
}
7000157c:	bf00      	nop
7000157e:	bf00      	nop
70001580:	3710      	adds	r7, #16
70001582:	46bd      	mov	sp, r7
70001584:	bd80      	pop	{r7, pc}
70001586:	bf00      	nop
70001588:	2400002c 	.word	0x2400002c

7000158c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
7000158c:	b480      	push	{r7}
7000158e:	b085      	sub	sp, #20
70001590:	af00      	add	r7, sp, #0
70001592:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
70001594:	687b      	ldr	r3, [r7, #4]
70001596:	f003 0307 	and.w	r3, r3, #7
7000159a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
7000159c:	4b0b      	ldr	r3, [pc, #44]	@ (700015cc <__NVIC_SetPriorityGrouping+0x40>)
7000159e:	68db      	ldr	r3, [r3, #12]
700015a0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
700015a2:	68ba      	ldr	r2, [r7, #8]
700015a4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
700015a8:	4013      	ands	r3, r2
700015aa:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
700015ac:	68fb      	ldr	r3, [r7, #12]
700015ae:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
700015b0:	68bb      	ldr	r3, [r7, #8]
700015b2:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
700015b4:	4b06      	ldr	r3, [pc, #24]	@ (700015d0 <__NVIC_SetPriorityGrouping+0x44>)
700015b6:	4313      	orrs	r3, r2
700015b8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
700015ba:	4a04      	ldr	r2, [pc, #16]	@ (700015cc <__NVIC_SetPriorityGrouping+0x40>)
700015bc:	68bb      	ldr	r3, [r7, #8]
700015be:	60d3      	str	r3, [r2, #12]
}
700015c0:	bf00      	nop
700015c2:	3714      	adds	r7, #20
700015c4:	46bd      	mov	sp, r7
700015c6:	f85d 7b04 	ldr.w	r7, [sp], #4
700015ca:	4770      	bx	lr
700015cc:	e000ed00 	.word	0xe000ed00
700015d0:	05fa0000 	.word	0x05fa0000

700015d4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
700015d4:	b480      	push	{r7}
700015d6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
700015d8:	4b04      	ldr	r3, [pc, #16]	@ (700015ec <__NVIC_GetPriorityGrouping+0x18>)
700015da:	68db      	ldr	r3, [r3, #12]
700015dc:	0a1b      	lsrs	r3, r3, #8
700015de:	f003 0307 	and.w	r3, r3, #7
}
700015e2:	4618      	mov	r0, r3
700015e4:	46bd      	mov	sp, r7
700015e6:	f85d 7b04 	ldr.w	r7, [sp], #4
700015ea:	4770      	bx	lr
700015ec:	e000ed00 	.word	0xe000ed00

700015f0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
700015f0:	b480      	push	{r7}
700015f2:	b083      	sub	sp, #12
700015f4:	af00      	add	r7, sp, #0
700015f6:	4603      	mov	r3, r0
700015f8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
700015fa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
700015fe:	2b00      	cmp	r3, #0
70001600:	db0b      	blt.n	7000161a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
70001602:	88fb      	ldrh	r3, [r7, #6]
70001604:	f003 021f 	and.w	r2, r3, #31
70001608:	4907      	ldr	r1, [pc, #28]	@ (70001628 <__NVIC_EnableIRQ+0x38>)
7000160a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
7000160e:	095b      	lsrs	r3, r3, #5
70001610:	2001      	movs	r0, #1
70001612:	fa00 f202 	lsl.w	r2, r0, r2
70001616:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
7000161a:	bf00      	nop
7000161c:	370c      	adds	r7, #12
7000161e:	46bd      	mov	sp, r7
70001620:	f85d 7b04 	ldr.w	r7, [sp], #4
70001624:	4770      	bx	lr
70001626:	bf00      	nop
70001628:	e000e100 	.word	0xe000e100

7000162c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
7000162c:	b480      	push	{r7}
7000162e:	b083      	sub	sp, #12
70001630:	af00      	add	r7, sp, #0
70001632:	4603      	mov	r3, r0
70001634:	6039      	str	r1, [r7, #0]
70001636:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
70001638:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
7000163c:	2b00      	cmp	r3, #0
7000163e:	db0a      	blt.n	70001656 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
70001640:	683b      	ldr	r3, [r7, #0]
70001642:	b2da      	uxtb	r2, r3
70001644:	490c      	ldr	r1, [pc, #48]	@ (70001678 <__NVIC_SetPriority+0x4c>)
70001646:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
7000164a:	0112      	lsls	r2, r2, #4
7000164c:	b2d2      	uxtb	r2, r2
7000164e:	440b      	add	r3, r1
70001650:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
70001654:	e00a      	b.n	7000166c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
70001656:	683b      	ldr	r3, [r7, #0]
70001658:	b2da      	uxtb	r2, r3
7000165a:	4908      	ldr	r1, [pc, #32]	@ (7000167c <__NVIC_SetPriority+0x50>)
7000165c:	88fb      	ldrh	r3, [r7, #6]
7000165e:	f003 030f 	and.w	r3, r3, #15
70001662:	3b04      	subs	r3, #4
70001664:	0112      	lsls	r2, r2, #4
70001666:	b2d2      	uxtb	r2, r2
70001668:	440b      	add	r3, r1
7000166a:	761a      	strb	r2, [r3, #24]
}
7000166c:	bf00      	nop
7000166e:	370c      	adds	r7, #12
70001670:	46bd      	mov	sp, r7
70001672:	f85d 7b04 	ldr.w	r7, [sp], #4
70001676:	4770      	bx	lr
70001678:	e000e100 	.word	0xe000e100
7000167c:	e000ed00 	.word	0xe000ed00

70001680 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
70001680:	b480      	push	{r7}
70001682:	b089      	sub	sp, #36	@ 0x24
70001684:	af00      	add	r7, sp, #0
70001686:	60f8      	str	r0, [r7, #12]
70001688:	60b9      	str	r1, [r7, #8]
7000168a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
7000168c:	68fb      	ldr	r3, [r7, #12]
7000168e:	f003 0307 	and.w	r3, r3, #7
70001692:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
70001694:	69fb      	ldr	r3, [r7, #28]
70001696:	f1c3 0307 	rsb	r3, r3, #7
7000169a:	2b04      	cmp	r3, #4
7000169c:	bf28      	it	cs
7000169e:	2304      	movcs	r3, #4
700016a0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
700016a2:	69fb      	ldr	r3, [r7, #28]
700016a4:	3304      	adds	r3, #4
700016a6:	2b06      	cmp	r3, #6
700016a8:	d902      	bls.n	700016b0 <NVIC_EncodePriority+0x30>
700016aa:	69fb      	ldr	r3, [r7, #28]
700016ac:	3b03      	subs	r3, #3
700016ae:	e000      	b.n	700016b2 <NVIC_EncodePriority+0x32>
700016b0:	2300      	movs	r3, #0
700016b2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
700016b4:	f04f 32ff 	mov.w	r2, #4294967295
700016b8:	69bb      	ldr	r3, [r7, #24]
700016ba:	fa02 f303 	lsl.w	r3, r2, r3
700016be:	43da      	mvns	r2, r3
700016c0:	68bb      	ldr	r3, [r7, #8]
700016c2:	401a      	ands	r2, r3
700016c4:	697b      	ldr	r3, [r7, #20]
700016c6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
700016c8:	f04f 31ff 	mov.w	r1, #4294967295
700016cc:	697b      	ldr	r3, [r7, #20]
700016ce:	fa01 f303 	lsl.w	r3, r1, r3
700016d2:	43d9      	mvns	r1, r3
700016d4:	687b      	ldr	r3, [r7, #4]
700016d6:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
700016d8:	4313      	orrs	r3, r2
         );
}
700016da:	4618      	mov	r0, r3
700016dc:	3724      	adds	r7, #36	@ 0x24
700016de:	46bd      	mov	sp, r7
700016e0:	f85d 7b04 	ldr.w	r7, [sp], #4
700016e4:	4770      	bx	lr
	...

700016e8 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
700016e8:	b580      	push	{r7, lr}
700016ea:	b082      	sub	sp, #8
700016ec:	af00      	add	r7, sp, #0
700016ee:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
700016f0:	687b      	ldr	r3, [r7, #4]
700016f2:	3b01      	subs	r3, #1
700016f4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
700016f8:	d301      	bcc.n	700016fe <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
700016fa:	2301      	movs	r3, #1
700016fc:	e00f      	b.n	7000171e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
700016fe:	4a0a      	ldr	r2, [pc, #40]	@ (70001728 <SysTick_Config+0x40>)
70001700:	687b      	ldr	r3, [r7, #4]
70001702:	3b01      	subs	r3, #1
70001704:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
70001706:	210f      	movs	r1, #15
70001708:	f04f 30ff 	mov.w	r0, #4294967295
7000170c:	f7ff ff8e 	bl	7000162c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
70001710:	4b05      	ldr	r3, [pc, #20]	@ (70001728 <SysTick_Config+0x40>)
70001712:	2200      	movs	r2, #0
70001714:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
70001716:	4b04      	ldr	r3, [pc, #16]	@ (70001728 <SysTick_Config+0x40>)
70001718:	2207      	movs	r2, #7
7000171a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
7000171c:	2300      	movs	r3, #0
}
7000171e:	4618      	mov	r0, r3
70001720:	3708      	adds	r7, #8
70001722:	46bd      	mov	sp, r7
70001724:	bd80      	pop	{r7, pc}
70001726:	bf00      	nop
70001728:	e000e010 	.word	0xe000e010

7000172c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
7000172c:	b580      	push	{r7, lr}
7000172e:	b082      	sub	sp, #8
70001730:	af00      	add	r7, sp, #0
70001732:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
70001734:	6878      	ldr	r0, [r7, #4]
70001736:	f7ff ff29 	bl	7000158c <__NVIC_SetPriorityGrouping>
}
7000173a:	bf00      	nop
7000173c:	3708      	adds	r7, #8
7000173e:	46bd      	mov	sp, r7
70001740:	bd80      	pop	{r7, pc}

70001742 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
70001742:	b580      	push	{r7, lr}
70001744:	b086      	sub	sp, #24
70001746:	af00      	add	r7, sp, #0
70001748:	4603      	mov	r3, r0
7000174a:	60b9      	str	r1, [r7, #8]
7000174c:	607a      	str	r2, [r7, #4]
7000174e:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIO_INTERRUPT(IRQn));
  prioritygroup = NVIC_GetPriorityGrouping();
70001750:	f7ff ff40 	bl	700015d4 <__NVIC_GetPriorityGrouping>
70001754:	6178      	str	r0, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
70001756:	687a      	ldr	r2, [r7, #4]
70001758:	68b9      	ldr	r1, [r7, #8]
7000175a:	6978      	ldr	r0, [r7, #20]
7000175c:	f7ff ff90 	bl	70001680 <NVIC_EncodePriority>
70001760:	4602      	mov	r2, r0
70001762:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
70001766:	4611      	mov	r1, r2
70001768:	4618      	mov	r0, r3
7000176a:	f7ff ff5f 	bl	7000162c <__NVIC_SetPriority>
}
7000176e:	bf00      	nop
70001770:	3718      	adds	r7, #24
70001772:	46bd      	mov	sp, r7
70001774:	bd80      	pop	{r7, pc}

70001776 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32h7rsxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
70001776:	b580      	push	{r7, lr}
70001778:	b082      	sub	sp, #8
7000177a:	af00      	add	r7, sp, #0
7000177c:	4603      	mov	r3, r0
7000177e:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
70001780:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
70001784:	4618      	mov	r0, r3
70001786:	f7ff ff33 	bl	700015f0 <__NVIC_EnableIRQ>
}
7000178a:	bf00      	nop
7000178c:	3708      	adds	r7, #8
7000178e:	46bd      	mov	sp, r7
70001790:	bd80      	pop	{r7, pc}

70001792 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
70001792:	b580      	push	{r7, lr}
70001794:	b082      	sub	sp, #8
70001796:	af00      	add	r7, sp, #0
70001798:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
7000179a:	6878      	ldr	r0, [r7, #4]
7000179c:	f7ff ffa4 	bl	700016e8 <SysTick_Config>
700017a0:	4603      	mov	r3, r0
}
700017a2:	4618      	mov	r0, r3
700017a4:	3708      	adds	r7, #8
700017a6:	46bd      	mov	sp, r7
700017a8:	bd80      	pop	{r7, pc}

700017aa <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
700017aa:	b480      	push	{r7}
700017ac:	b087      	sub	sp, #28
700017ae:	af00      	add	r7, sp, #0
700017b0:	60f8      	str	r0, [r7, #12]
700017b2:	460b      	mov	r3, r1
700017b4:	607a      	str	r2, [r7, #4]
700017b6:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
700017b8:	2300      	movs	r3, #0
700017ba:	75fb      	strb	r3, [r7, #23]

  switch (CallbackID)
700017bc:	7afb      	ldrb	r3, [r7, #11]
700017be:	2b00      	cmp	r3, #0
700017c0:	d103      	bne.n	700017ca <HAL_EXTI_RegisterCallback+0x20>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
700017c2:	68fb      	ldr	r3, [r7, #12]
700017c4:	687a      	ldr	r2, [r7, #4]
700017c6:	605a      	str	r2, [r3, #4]
      break;
700017c8:	e002      	b.n	700017d0 <HAL_EXTI_RegisterCallback+0x26>

    default:
      status = HAL_ERROR;
700017ca:	2301      	movs	r3, #1
700017cc:	75fb      	strb	r3, [r7, #23]
      break;
700017ce:	bf00      	nop
  }

  return status;
700017d0:	7dfb      	ldrb	r3, [r7, #23]
}
700017d2:	4618      	mov	r0, r3
700017d4:	371c      	adds	r7, #28
700017d6:	46bd      	mov	sp, r7
700017d8:	f85d 7b04 	ldr.w	r7, [sp], #4
700017dc:	4770      	bx	lr

700017de <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
700017de:	b480      	push	{r7}
700017e0:	b083      	sub	sp, #12
700017e2:	af00      	add	r7, sp, #0
700017e4:	6078      	str	r0, [r7, #4]
700017e6:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
700017e8:	687b      	ldr	r3, [r7, #4]
700017ea:	2b00      	cmp	r3, #0
700017ec:	d101      	bne.n	700017f2 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
700017ee:	2301      	movs	r3, #1
700017f0:	e003      	b.n	700017fa <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
700017f2:	687b      	ldr	r3, [r7, #4]
700017f4:	683a      	ldr	r2, [r7, #0]
700017f6:	601a      	str	r2, [r3, #0]

    return HAL_OK;
700017f8:	2300      	movs	r3, #0
  }
}
700017fa:	4618      	mov	r0, r3
700017fc:	370c      	adds	r7, #12
700017fe:	46bd      	mov	sp, r7
70001800:	f85d 7b04 	ldr.w	r7, [sp], #4
70001804:	4770      	bx	lr
	...

70001808 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(const EXTI_HandleTypeDef *hexti)
{
70001808:	b580      	push	{r7, lr}
7000180a:	b086      	sub	sp, #24
7000180c:	af00      	add	r7, sp, #0
7000180e:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
70001810:	687b      	ldr	r3, [r7, #4]
70001812:	681b      	ldr	r3, [r3, #0]
70001814:	0c1b      	lsrs	r3, r3, #16
70001816:	f003 0303 	and.w	r3, r3, #3
7000181a:	617b      	str	r3, [r7, #20]
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
7000181c:	687b      	ldr	r3, [r7, #4]
7000181e:	681b      	ldr	r3, [r3, #0]
70001820:	f003 031f 	and.w	r3, r3, #31
70001824:	2201      	movs	r2, #1
70001826:	fa02 f303 	lsl.w	r3, r2, r3
7000182a:	613b      	str	r3, [r7, #16]

  /* Get pending bit  */
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
7000182c:	697b      	ldr	r3, [r7, #20]
7000182e:	011a      	lsls	r2, r3, #4
70001830:	4b0c      	ldr	r3, [pc, #48]	@ (70001864 <HAL_EXTI_IRQHandler+0x5c>)
70001832:	4413      	add	r3, r2
70001834:	60fb      	str	r3, [r7, #12]
  regval = (*regaddr & maskline);
70001836:	68fb      	ldr	r3, [r7, #12]
70001838:	681b      	ldr	r3, [r3, #0]
7000183a:	693a      	ldr	r2, [r7, #16]
7000183c:	4013      	ands	r3, r2
7000183e:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00u)
70001840:	68bb      	ldr	r3, [r7, #8]
70001842:	2b00      	cmp	r3, #0
70001844:	d009      	beq.n	7000185a <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
70001846:	68fb      	ldr	r3, [r7, #12]
70001848:	693a      	ldr	r2, [r7, #16]
7000184a:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
7000184c:	687b      	ldr	r3, [r7, #4]
7000184e:	685b      	ldr	r3, [r3, #4]
70001850:	2b00      	cmp	r3, #0
70001852:	d002      	beq.n	7000185a <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
70001854:	687b      	ldr	r3, [r7, #4]
70001856:	685b      	ldr	r3, [r3, #4]
70001858:	4798      	blx	r3
    }
  }
}
7000185a:	bf00      	nop
7000185c:	3718      	adds	r7, #24
7000185e:	46bd      	mov	sp, r7
70001860:	bd80      	pop	{r7, pc}
70001862:	bf00      	nop
70001864:	58000088 	.word	0x58000088

70001868 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
70001868:	b480      	push	{r7}
7000186a:	b087      	sub	sp, #28
7000186c:	af00      	add	r7, sp, #0
7000186e:	6078      	str	r0, [r7, #4]
70001870:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
70001872:	2300      	movs	r3, #0
70001874:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
70001876:	e139      	b.n	70001aec <HAL_GPIO_Init+0x284>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
70001878:	683b      	ldr	r3, [r7, #0]
7000187a:	681a      	ldr	r2, [r3, #0]
7000187c:	2101      	movs	r1, #1
7000187e:	697b      	ldr	r3, [r7, #20]
70001880:	fa01 f303 	lsl.w	r3, r1, r3
70001884:	4013      	ands	r3, r2
70001886:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
70001888:	68fb      	ldr	r3, [r7, #12]
7000188a:	2b00      	cmp	r3, #0
7000188c:	f000 812b 	beq.w	70001ae6 <HAL_GPIO_Init+0x27e>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
70001890:	683b      	ldr	r3, [r7, #0]
70001892:	685b      	ldr	r3, [r3, #4]
70001894:	f003 0303 	and.w	r3, r3, #3
70001898:	2b01      	cmp	r3, #1
7000189a:	d005      	beq.n	700018a8 <HAL_GPIO_Init+0x40>
7000189c:	683b      	ldr	r3, [r7, #0]
7000189e:	685b      	ldr	r3, [r3, #4]
700018a0:	f003 0303 	and.w	r3, r3, #3
700018a4:	2b02      	cmp	r3, #2
700018a6:	d130      	bne.n	7000190a <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
700018a8:	687b      	ldr	r3, [r7, #4]
700018aa:	689b      	ldr	r3, [r3, #8]
700018ac:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
700018ae:	697b      	ldr	r3, [r7, #20]
700018b0:	005b      	lsls	r3, r3, #1
700018b2:	2203      	movs	r2, #3
700018b4:	fa02 f303 	lsl.w	r3, r2, r3
700018b8:	43db      	mvns	r3, r3
700018ba:	693a      	ldr	r2, [r7, #16]
700018bc:	4013      	ands	r3, r2
700018be:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
700018c0:	683b      	ldr	r3, [r7, #0]
700018c2:	68da      	ldr	r2, [r3, #12]
700018c4:	697b      	ldr	r3, [r7, #20]
700018c6:	005b      	lsls	r3, r3, #1
700018c8:	fa02 f303 	lsl.w	r3, r2, r3
700018cc:	693a      	ldr	r2, [r7, #16]
700018ce:	4313      	orrs	r3, r2
700018d0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
700018d2:	687b      	ldr	r3, [r7, #4]
700018d4:	693a      	ldr	r2, [r7, #16]
700018d6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
700018d8:	687b      	ldr	r3, [r7, #4]
700018da:	685b      	ldr	r3, [r3, #4]
700018dc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
700018de:	2201      	movs	r2, #1
700018e0:	697b      	ldr	r3, [r7, #20]
700018e2:	fa02 f303 	lsl.w	r3, r2, r3
700018e6:	43db      	mvns	r3, r3
700018e8:	693a      	ldr	r2, [r7, #16]
700018ea:	4013      	ands	r3, r2
700018ec:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
700018ee:	683b      	ldr	r3, [r7, #0]
700018f0:	685b      	ldr	r3, [r3, #4]
700018f2:	091b      	lsrs	r3, r3, #4
700018f4:	f003 0201 	and.w	r2, r3, #1
700018f8:	697b      	ldr	r3, [r7, #20]
700018fa:	fa02 f303 	lsl.w	r3, r2, r3
700018fe:	693a      	ldr	r2, [r7, #16]
70001900:	4313      	orrs	r3, r2
70001902:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
70001904:	687b      	ldr	r3, [r7, #4]
70001906:	693a      	ldr	r2, [r7, #16]
70001908:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
7000190a:	683b      	ldr	r3, [r7, #0]
7000190c:	685b      	ldr	r3, [r3, #4]
7000190e:	f003 0303 	and.w	r3, r3, #3
70001912:	2b03      	cmp	r3, #3
70001914:	d017      	beq.n	70001946 <HAL_GPIO_Init+0xde>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
70001916:	687b      	ldr	r3, [r7, #4]
70001918:	68db      	ldr	r3, [r3, #12]
7000191a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
7000191c:	697b      	ldr	r3, [r7, #20]
7000191e:	005b      	lsls	r3, r3, #1
70001920:	2203      	movs	r2, #3
70001922:	fa02 f303 	lsl.w	r3, r2, r3
70001926:	43db      	mvns	r3, r3
70001928:	693a      	ldr	r2, [r7, #16]
7000192a:	4013      	ands	r3, r2
7000192c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
7000192e:	683b      	ldr	r3, [r7, #0]
70001930:	689a      	ldr	r2, [r3, #8]
70001932:	697b      	ldr	r3, [r7, #20]
70001934:	005b      	lsls	r3, r3, #1
70001936:	fa02 f303 	lsl.w	r3, r2, r3
7000193a:	693a      	ldr	r2, [r7, #16]
7000193c:	4313      	orrs	r3, r2
7000193e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
70001940:	687b      	ldr	r3, [r7, #4]
70001942:	693a      	ldr	r2, [r7, #16]
70001944:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
70001946:	683b      	ldr	r3, [r7, #0]
70001948:	685b      	ldr	r3, [r3, #4]
7000194a:	f003 0303 	and.w	r3, r3, #3
7000194e:	2b02      	cmp	r3, #2
70001950:	d123      	bne.n	7000199a <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
70001952:	697b      	ldr	r3, [r7, #20]
70001954:	08da      	lsrs	r2, r3, #3
70001956:	687b      	ldr	r3, [r7, #4]
70001958:	3208      	adds	r2, #8
7000195a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
7000195e:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
70001960:	697b      	ldr	r3, [r7, #20]
70001962:	f003 0307 	and.w	r3, r3, #7
70001966:	009b      	lsls	r3, r3, #2
70001968:	220f      	movs	r2, #15
7000196a:	fa02 f303 	lsl.w	r3, r2, r3
7000196e:	43db      	mvns	r3, r3
70001970:	693a      	ldr	r2, [r7, #16]
70001972:	4013      	ands	r3, r2
70001974:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
70001976:	683b      	ldr	r3, [r7, #0]
70001978:	691a      	ldr	r2, [r3, #16]
7000197a:	697b      	ldr	r3, [r7, #20]
7000197c:	f003 0307 	and.w	r3, r3, #7
70001980:	009b      	lsls	r3, r3, #2
70001982:	fa02 f303 	lsl.w	r3, r2, r3
70001986:	693a      	ldr	r2, [r7, #16]
70001988:	4313      	orrs	r3, r2
7000198a:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
7000198c:	697b      	ldr	r3, [r7, #20]
7000198e:	08da      	lsrs	r2, r3, #3
70001990:	687b      	ldr	r3, [r7, #4]
70001992:	3208      	adds	r2, #8
70001994:	6939      	ldr	r1, [r7, #16]
70001996:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
7000199a:	687b      	ldr	r3, [r7, #4]
7000199c:	681b      	ldr	r3, [r3, #0]
7000199e:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
700019a0:	697b      	ldr	r3, [r7, #20]
700019a2:	005b      	lsls	r3, r3, #1
700019a4:	2203      	movs	r2, #3
700019a6:	fa02 f303 	lsl.w	r3, r2, r3
700019aa:	43db      	mvns	r3, r3
700019ac:	693a      	ldr	r2, [r7, #16]
700019ae:	4013      	ands	r3, r2
700019b0:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
700019b2:	683b      	ldr	r3, [r7, #0]
700019b4:	685b      	ldr	r3, [r3, #4]
700019b6:	f003 0203 	and.w	r2, r3, #3
700019ba:	697b      	ldr	r3, [r7, #20]
700019bc:	005b      	lsls	r3, r3, #1
700019be:	fa02 f303 	lsl.w	r3, r2, r3
700019c2:	693a      	ldr	r2, [r7, #16]
700019c4:	4313      	orrs	r3, r2
700019c6:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
700019c8:	687b      	ldr	r3, [r7, #4]
700019ca:	693a      	ldr	r2, [r7, #16]
700019cc:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
700019ce:	683b      	ldr	r3, [r7, #0]
700019d0:	685b      	ldr	r3, [r3, #4]
700019d2:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
700019d6:	2b00      	cmp	r3, #0
700019d8:	f000 8085 	beq.w	70001ae6 <HAL_GPIO_Init+0x27e>
      {
        temp = SBS->EXTICR[position >> 2u];
700019dc:	4a4b      	ldr	r2, [pc, #300]	@ (70001b0c <HAL_GPIO_Init+0x2a4>)
700019de:	697b      	ldr	r3, [r7, #20]
700019e0:	089b      	lsrs	r3, r3, #2
700019e2:	334c      	adds	r3, #76	@ 0x4c
700019e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
700019e8:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * SBS_EXTICR1_PC_EXTI1_Pos));
700019ea:	697b      	ldr	r3, [r7, #20]
700019ec:	f003 0303 	and.w	r3, r3, #3
700019f0:	009b      	lsls	r3, r3, #2
700019f2:	220f      	movs	r2, #15
700019f4:	fa02 f303 	lsl.w	r3, r2, r3
700019f8:	43db      	mvns	r3, r3
700019fa:	693a      	ldr	r2, [r7, #16]
700019fc:	4013      	ands	r3, r2
700019fe:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * SBS_EXTICR1_PC_EXTI1_Pos));
70001a00:	687b      	ldr	r3, [r7, #4]
70001a02:	0a9a      	lsrs	r2, r3, #10
70001a04:	4b42      	ldr	r3, [pc, #264]	@ (70001b10 <HAL_GPIO_Init+0x2a8>)
70001a06:	4013      	ands	r3, r2
70001a08:	697a      	ldr	r2, [r7, #20]
70001a0a:	f002 0203 	and.w	r2, r2, #3
70001a0e:	0092      	lsls	r2, r2, #2
70001a10:	4093      	lsls	r3, r2
70001a12:	693a      	ldr	r2, [r7, #16]
70001a14:	4313      	orrs	r3, r2
70001a16:	613b      	str	r3, [r7, #16]
        SBS->EXTICR[position >> 2u] = temp;
70001a18:	493c      	ldr	r1, [pc, #240]	@ (70001b0c <HAL_GPIO_Init+0x2a4>)
70001a1a:	697b      	ldr	r3, [r7, #20]
70001a1c:	089b      	lsrs	r3, r3, #2
70001a1e:	334c      	adds	r3, #76	@ 0x4c
70001a20:	693a      	ldr	r2, [r7, #16]
70001a22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
70001a26:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001a2a:	681b      	ldr	r3, [r3, #0]
70001a2c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001a2e:	68fb      	ldr	r3, [r7, #12]
70001a30:	43db      	mvns	r3, r3
70001a32:	693a      	ldr	r2, [r7, #16]
70001a34:	4013      	ands	r3, r2
70001a36:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
70001a38:	683b      	ldr	r3, [r7, #0]
70001a3a:	685b      	ldr	r3, [r3, #4]
70001a3c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
70001a40:	2b00      	cmp	r3, #0
70001a42:	d003      	beq.n	70001a4c <HAL_GPIO_Init+0x1e4>
        {
          temp |= iocurrent;
70001a44:	693a      	ldr	r2, [r7, #16]
70001a46:	68fb      	ldr	r3, [r7, #12]
70001a48:	4313      	orrs	r3, r2
70001a4a:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
70001a4c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001a50:	693b      	ldr	r3, [r7, #16]
70001a52:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
70001a54:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001a58:	685b      	ldr	r3, [r3, #4]
70001a5a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001a5c:	68fb      	ldr	r3, [r7, #12]
70001a5e:	43db      	mvns	r3, r3
70001a60:	693a      	ldr	r2, [r7, #16]
70001a62:	4013      	ands	r3, r2
70001a64:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
70001a66:	683b      	ldr	r3, [r7, #0]
70001a68:	685b      	ldr	r3, [r3, #4]
70001a6a:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
70001a6e:	2b00      	cmp	r3, #0
70001a70:	d003      	beq.n	70001a7a <HAL_GPIO_Init+0x212>
        {
          temp |= iocurrent;
70001a72:	693a      	ldr	r2, [r7, #16]
70001a74:	68fb      	ldr	r3, [r7, #12]
70001a76:	4313      	orrs	r3, r2
70001a78:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
70001a7a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001a7e:	693b      	ldr	r3, [r7, #16]
70001a80:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->EMR1;
70001a82:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001a86:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
70001a8a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001a8c:	68fb      	ldr	r3, [r7, #12]
70001a8e:	43db      	mvns	r3, r3
70001a90:	693a      	ldr	r2, [r7, #16]
70001a92:	4013      	ands	r3, r2
70001a94:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
70001a96:	683b      	ldr	r3, [r7, #0]
70001a98:	685b      	ldr	r3, [r3, #4]
70001a9a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70001a9e:	2b00      	cmp	r3, #0
70001aa0:	d003      	beq.n	70001aaa <HAL_GPIO_Init+0x242>
        {
          temp |= iocurrent;
70001aa2:	693a      	ldr	r2, [r7, #16]
70001aa4:	68fb      	ldr	r3, [r7, #12]
70001aa6:	4313      	orrs	r3, r2
70001aa8:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
70001aaa:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001aae:	693b      	ldr	r3, [r7, #16]
70001ab0:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        temp = EXTI->IMR1;
70001ab4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001ab8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
70001abc:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001abe:	68fb      	ldr	r3, [r7, #12]
70001ac0:	43db      	mvns	r3, r3
70001ac2:	693a      	ldr	r2, [r7, #16]
70001ac4:	4013      	ands	r3, r2
70001ac6:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
70001ac8:	683b      	ldr	r3, [r7, #0]
70001aca:	685b      	ldr	r3, [r3, #4]
70001acc:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70001ad0:	2b00      	cmp	r3, #0
70001ad2:	d003      	beq.n	70001adc <HAL_GPIO_Init+0x274>
        {
          temp |= iocurrent;
70001ad4:	693a      	ldr	r2, [r7, #16]
70001ad6:	68fb      	ldr	r3, [r7, #12]
70001ad8:	4313      	orrs	r3, r2
70001ada:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
70001adc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001ae0:	693b      	ldr	r3, [r7, #16]
70001ae2:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }

    position++;
70001ae6:	697b      	ldr	r3, [r7, #20]
70001ae8:	3301      	adds	r3, #1
70001aea:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
70001aec:	683b      	ldr	r3, [r7, #0]
70001aee:	681a      	ldr	r2, [r3, #0]
70001af0:	697b      	ldr	r3, [r7, #20]
70001af2:	fa22 f303 	lsr.w	r3, r2, r3
70001af6:	2b00      	cmp	r3, #0
70001af8:	f47f aebe 	bne.w	70001878 <HAL_GPIO_Init+0x10>
  }
}
70001afc:	bf00      	nop
70001afe:	bf00      	nop
70001b00:	371c      	adds	r7, #28
70001b02:	46bd      	mov	sp, r7
70001b04:	f85d 7b04 	ldr.w	r7, [sp], #4
70001b08:	4770      	bx	lr
70001b0a:	bf00      	nop
70001b0c:	58000400 	.word	0x58000400
70001b10:	0029ff7f 	.word	0x0029ff7f

70001b14 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
70001b14:	b480      	push	{r7}
70001b16:	b083      	sub	sp, #12
70001b18:	af00      	add	r7, sp, #0
70001b1a:	6078      	str	r0, [r7, #4]
70001b1c:	460b      	mov	r3, r1
70001b1e:	807b      	strh	r3, [r7, #2]
70001b20:	4613      	mov	r3, r2
70001b22:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
70001b24:	787b      	ldrb	r3, [r7, #1]
70001b26:	2b00      	cmp	r3, #0
70001b28:	d003      	beq.n	70001b32 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
70001b2a:	887a      	ldrh	r2, [r7, #2]
70001b2c:	687b      	ldr	r3, [r7, #4]
70001b2e:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
70001b30:	e002      	b.n	70001b38 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
70001b32:	887a      	ldrh	r2, [r7, #2]
70001b34:	687b      	ldr	r3, [r7, #4]
70001b36:	629a      	str	r2, [r3, #40]	@ 0x28
}
70001b38:	bf00      	nop
70001b3a:	370c      	adds	r7, #12
70001b3c:	46bd      	mov	sp, r7
70001b3e:	f85d 7b04 	ldr.w	r7, [sp], #4
70001b42:	4770      	bx	lr

70001b44 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
70001b44:	b480      	push	{r7}
70001b46:	b085      	sub	sp, #20
70001b48:	af00      	add	r7, sp, #0
70001b4a:	6078      	str	r0, [r7, #4]
70001b4c:	460b      	mov	r3, r1
70001b4e:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
70001b50:	687b      	ldr	r3, [r7, #4]
70001b52:	695b      	ldr	r3, [r3, #20]
70001b54:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
70001b56:	887a      	ldrh	r2, [r7, #2]
70001b58:	68fb      	ldr	r3, [r7, #12]
70001b5a:	4013      	ands	r3, r2
70001b5c:	041a      	lsls	r2, r3, #16
70001b5e:	68fb      	ldr	r3, [r7, #12]
70001b60:	43d9      	mvns	r1, r3
70001b62:	887b      	ldrh	r3, [r7, #2]
70001b64:	400b      	ands	r3, r1
70001b66:	431a      	orrs	r2, r3
70001b68:	687b      	ldr	r3, [r7, #4]
70001b6a:	619a      	str	r2, [r3, #24]
}
70001b6c:	bf00      	nop
70001b6e:	3714      	adds	r7, #20
70001b70:	46bd      	mov	sp, r7
70001b72:	f85d 7b04 	ldr.w	r7, [sp], #4
70001b76:	4770      	bx	lr

70001b78 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
70001b78:	b480      	push	{r7}
70001b7a:	b08b      	sub	sp, #44	@ 0x2c
70001b7c:	af00      	add	r7, sp, #0
  uint32_t sysclockfreq;
  uint32_t prescaler;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
70001b7e:	4baa      	ldr	r3, [pc, #680]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001b80:	691b      	ldr	r3, [r3, #16]
70001b82:	f003 0338 	and.w	r3, r3, #56	@ 0x38
70001b86:	2b18      	cmp	r3, #24
70001b88:	f200 8136 	bhi.w	70001df8 <HAL_RCC_GetSysClockFreq+0x280>
70001b8c:	a201      	add	r2, pc, #4	@ (adr r2, 70001b94 <HAL_RCC_GetSysClockFreq+0x1c>)
70001b8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70001b92:	bf00      	nop
70001b94:	70001bf9 	.word	0x70001bf9
70001b98:	70001df9 	.word	0x70001df9
70001b9c:	70001df9 	.word	0x70001df9
70001ba0:	70001df9 	.word	0x70001df9
70001ba4:	70001df9 	.word	0x70001df9
70001ba8:	70001df9 	.word	0x70001df9
70001bac:	70001df9 	.word	0x70001df9
70001bb0:	70001df9 	.word	0x70001df9
70001bb4:	70001c1f 	.word	0x70001c1f
70001bb8:	70001df9 	.word	0x70001df9
70001bbc:	70001df9 	.word	0x70001df9
70001bc0:	70001df9 	.word	0x70001df9
70001bc4:	70001df9 	.word	0x70001df9
70001bc8:	70001df9 	.word	0x70001df9
70001bcc:	70001df9 	.word	0x70001df9
70001bd0:	70001df9 	.word	0x70001df9
70001bd4:	70001c25 	.word	0x70001c25
70001bd8:	70001df9 	.word	0x70001df9
70001bdc:	70001df9 	.word	0x70001df9
70001be0:	70001df9 	.word	0x70001df9
70001be4:	70001df9 	.word	0x70001df9
70001be8:	70001df9 	.word	0x70001df9
70001bec:	70001df9 	.word	0x70001df9
70001bf0:	70001df9 	.word	0x70001df9
70001bf4:	70001c2b 	.word	0x70001c2b
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */

      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70001bf8:	4b8b      	ldr	r3, [pc, #556]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001bfa:	681b      	ldr	r3, [r3, #0]
70001bfc:	f003 0320 	and.w	r3, r3, #32
70001c00:	2b00      	cmp	r3, #0
70001c02:	d009      	beq.n	70001c18 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70001c04:	4b88      	ldr	r3, [pc, #544]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001c06:	681b      	ldr	r3, [r3, #0]
70001c08:	08db      	lsrs	r3, r3, #3
70001c0a:	f003 0303 	and.w	r3, r3, #3
70001c0e:	4a87      	ldr	r2, [pc, #540]	@ (70001e2c <HAL_RCC_GetSysClockFreq+0x2b4>)
70001c10:	fa22 f303 	lsr.w	r3, r2, r3
70001c14:	623b      	str	r3, [r7, #32]
      {
        /* Can't retrieve HSIDIV value */
        sysclockfreq = 0U;
      }

      break;
70001c16:	e0f2      	b.n	70001dfe <HAL_RCC_GetSysClockFreq+0x286>
        sysclockfreq = 0U;
70001c18:	2300      	movs	r3, #0
70001c1a:	623b      	str	r3, [r7, #32]
      break;
70001c1c:	e0ef      	b.n	70001dfe <HAL_RCC_GetSysClockFreq+0x286>

    case RCC_SYSCLKSOURCE_STATUS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
70001c1e:	4b84      	ldr	r3, [pc, #528]	@ (70001e30 <HAL_RCC_GetSysClockFreq+0x2b8>)
70001c20:	623b      	str	r3, [r7, #32]
      break;
70001c22:	e0ec      	b.n	70001dfe <HAL_RCC_GetSysClockFreq+0x286>

    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
70001c24:	4b83      	ldr	r3, [pc, #524]	@ (70001e34 <HAL_RCC_GetSysClockFreq+0x2bc>)
70001c26:	623b      	str	r3, [r7, #32]
      break;
70001c28:	e0e9      	b.n	70001dfe <HAL_RCC_GetSysClockFreq+0x286>
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
70001c2a:	4b7f      	ldr	r3, [pc, #508]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001c2c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70001c2e:	f003 0303 	and.w	r3, r3, #3
70001c32:	61fb      	str	r3, [r7, #28]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos)  ;
70001c34:	4b7c      	ldr	r3, [pc, #496]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001c36:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70001c38:	091b      	lsrs	r3, r3, #4
70001c3a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70001c3e:	61bb      	str	r3, [r7, #24]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
70001c40:	4b79      	ldr	r3, [pc, #484]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001c42:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70001c44:	f003 0301 	and.w	r3, r3, #1
70001c48:	617b      	str	r3, [r7, #20]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN) >> 3));
70001c4a:	4b77      	ldr	r3, [pc, #476]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001c4c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
70001c4e:	08db      	lsrs	r3, r3, #3
70001c50:	f3c3 030c 	ubfx	r3, r3, #0, #13
70001c54:	697a      	ldr	r2, [r7, #20]
70001c56:	fb02 f303 	mul.w	r3, r2, r3
70001c5a:	ee07 3a90 	vmov	s15, r3
70001c5e:	eef8 7a67 	vcvt.f32.u32	s15, s15
70001c62:	edc7 7a04 	vstr	s15, [r7, #16]

      if (pllm != 0U)
70001c66:	69bb      	ldr	r3, [r7, #24]
70001c68:	2b00      	cmp	r3, #0
70001c6a:	f000 80c2 	beq.w	70001df2 <HAL_RCC_GetSysClockFreq+0x27a>
70001c6e:	69fb      	ldr	r3, [r7, #28]
70001c70:	2b02      	cmp	r3, #2
70001c72:	d064      	beq.n	70001d3e <HAL_RCC_GetSysClockFreq+0x1c6>
70001c74:	69fb      	ldr	r3, [r7, #28]
70001c76:	2b02      	cmp	r3, #2
70001c78:	f200 8083 	bhi.w	70001d82 <HAL_RCC_GetSysClockFreq+0x20a>
70001c7c:	69fb      	ldr	r3, [r7, #28]
70001c7e:	2b00      	cmp	r3, #0
70001c80:	d003      	beq.n	70001c8a <HAL_RCC_GetSysClockFreq+0x112>
70001c82:	69fb      	ldr	r3, [r7, #28]
70001c84:	2b01      	cmp	r3, #1
70001c86:	d038      	beq.n	70001cfa <HAL_RCC_GetSysClockFreq+0x182>
70001c88:	e07b      	b.n	70001d82 <HAL_RCC_GetSysClockFreq+0x20a>
      {
        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70001c8a:	4b67      	ldr	r3, [pc, #412]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001c8c:	681b      	ldr	r3, [r3, #0]
70001c8e:	f003 0320 	and.w	r3, r3, #32
70001c92:	2b00      	cmp	r3, #0
70001c94:	d02d      	beq.n	70001cf2 <HAL_RCC_GetSysClockFreq+0x17a>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70001c96:	4b64      	ldr	r3, [pc, #400]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001c98:	681b      	ldr	r3, [r3, #0]
70001c9a:	08db      	lsrs	r3, r3, #3
70001c9c:	f003 0303 	and.w	r3, r3, #3
70001ca0:	4a62      	ldr	r2, [pc, #392]	@ (70001e2c <HAL_RCC_GetSysClockFreq+0x2b4>)
70001ca2:	fa22 f303 	lsr.w	r3, r2, r3
70001ca6:	60fb      	str	r3, [r7, #12]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
70001ca8:	68fb      	ldr	r3, [r7, #12]
70001caa:	ee07 3a90 	vmov	s15, r3
70001cae:	eef8 6a67 	vcvt.f32.u32	s13, s15
70001cb2:	69bb      	ldr	r3, [r7, #24]
70001cb4:	ee07 3a90 	vmov	s15, r3
70001cb8:	eef8 7a67 	vcvt.f32.u32	s15, s15
70001cbc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70001cc0:	4b59      	ldr	r3, [pc, #356]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001cc2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70001cc4:	f3c3 0308 	ubfx	r3, r3, #0, #9
70001cc8:	ee07 3a90 	vmov	s15, r3
70001ccc:	eef8 6a67 	vcvt.f32.u32	s13, s15
70001cd0:	ed97 6a04 	vldr	s12, [r7, #16]
70001cd4:	eddf 5a58 	vldr	s11, [pc, #352]	@ 70001e38 <HAL_RCC_GetSysClockFreq+0x2c0>
70001cd8:	eec6 7a25 	vdiv.f32	s15, s12, s11
70001cdc:	ee76 7aa7 	vadd.f32	s15, s13, s15
70001ce0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70001ce4:	ee77 7aa6 	vadd.f32	s15, s15, s13
70001ce8:	ee67 7a27 	vmul.f32	s15, s14, s15
70001cec:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            else
            {
              /* Can't retrieve HSIDIV value */
              pllvco = (float_t)0;
            }
            break;
70001cf0:	e069      	b.n	70001dc6 <HAL_RCC_GetSysClockFreq+0x24e>
              pllvco = (float_t)0;
70001cf2:	f04f 0300 	mov.w	r3, #0
70001cf6:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
70001cf8:	e065      	b.n	70001dc6 <HAL_RCC_GetSysClockFreq+0x24e>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
70001cfa:	69bb      	ldr	r3, [r7, #24]
70001cfc:	ee07 3a90 	vmov	s15, r3
70001d00:	eef8 7a67 	vcvt.f32.u32	s15, s15
70001d04:	eddf 6a4d 	vldr	s13, [pc, #308]	@ 70001e3c <HAL_RCC_GetSysClockFreq+0x2c4>
70001d08:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70001d0c:	4b46      	ldr	r3, [pc, #280]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001d0e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70001d10:	f3c3 0308 	ubfx	r3, r3, #0, #9
70001d14:	ee07 3a90 	vmov	s15, r3
70001d18:	eef8 6a67 	vcvt.f32.u32	s13, s15
70001d1c:	ed97 6a04 	vldr	s12, [r7, #16]
70001d20:	eddf 5a45 	vldr	s11, [pc, #276]	@ 70001e38 <HAL_RCC_GetSysClockFreq+0x2c0>
70001d24:	eec6 7a25 	vdiv.f32	s15, s12, s11
70001d28:	ee76 7aa7 	vadd.f32	s15, s13, s15
70001d2c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70001d30:	ee77 7aa6 	vadd.f32	s15, s15, s13
70001d34:	ee67 7a27 	vmul.f32	s15, s14, s15
70001d38:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
70001d3c:	e043      	b.n	70001dc6 <HAL_RCC_GetSysClockFreq+0x24e>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
70001d3e:	69bb      	ldr	r3, [r7, #24]
70001d40:	ee07 3a90 	vmov	s15, r3
70001d44:	eef8 7a67 	vcvt.f32.u32	s15, s15
70001d48:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 70001e40 <HAL_RCC_GetSysClockFreq+0x2c8>
70001d4c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70001d50:	4b35      	ldr	r3, [pc, #212]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001d52:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70001d54:	f3c3 0308 	ubfx	r3, r3, #0, #9
70001d58:	ee07 3a90 	vmov	s15, r3
70001d5c:	eef8 6a67 	vcvt.f32.u32	s13, s15
70001d60:	ed97 6a04 	vldr	s12, [r7, #16]
70001d64:	eddf 5a34 	vldr	s11, [pc, #208]	@ 70001e38 <HAL_RCC_GetSysClockFreq+0x2c0>
70001d68:	eec6 7a25 	vdiv.f32	s15, s12, s11
70001d6c:	ee76 7aa7 	vadd.f32	s15, s13, s15
70001d70:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70001d74:	ee77 7aa6 	vadd.f32	s15, s15, s13
70001d78:	ee67 7a27 	vmul.f32	s15, s14, s15
70001d7c:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
70001d80:	e021      	b.n	70001dc6 <HAL_RCC_GetSysClockFreq+0x24e>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
70001d82:	69bb      	ldr	r3, [r7, #24]
70001d84:	ee07 3a90 	vmov	s15, r3
70001d88:	eef8 7a67 	vcvt.f32.u32	s15, s15
70001d8c:	eddf 6a2b 	vldr	s13, [pc, #172]	@ 70001e3c <HAL_RCC_GetSysClockFreq+0x2c4>
70001d90:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70001d94:	4b24      	ldr	r3, [pc, #144]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001d96:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70001d98:	f3c3 0308 	ubfx	r3, r3, #0, #9
70001d9c:	ee07 3a90 	vmov	s15, r3
70001da0:	eef8 6a67 	vcvt.f32.u32	s13, s15
70001da4:	ed97 6a04 	vldr	s12, [r7, #16]
70001da8:	eddf 5a23 	vldr	s11, [pc, #140]	@ 70001e38 <HAL_RCC_GetSysClockFreq+0x2c0>
70001dac:	eec6 7a25 	vdiv.f32	s15, s12, s11
70001db0:	ee76 7aa7 	vadd.f32	s15, s13, s15
70001db4:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70001db8:	ee77 7aa6 	vadd.f32	s15, s15, s13
70001dbc:	ee67 7a27 	vmul.f32	s15, s14, s15
70001dc0:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
70001dc4:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVP) >> RCC_PLL1DIVR1_DIVP_Pos) + 1U) ;
70001dc6:	4b18      	ldr	r3, [pc, #96]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001dc8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70001dca:	0a5b      	lsrs	r3, r3, #9
70001dcc:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
70001dd0:	3301      	adds	r3, #1
70001dd2:	60bb      	str	r3, [r7, #8]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
70001dd4:	68bb      	ldr	r3, [r7, #8]
70001dd6:	ee07 3a90 	vmov	s15, r3
70001dda:	eeb8 7a67 	vcvt.f32.u32	s14, s15
70001dde:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
70001de2:	eec6 7a87 	vdiv.f32	s15, s13, s14
70001de6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
70001dea:	ee17 3a90 	vmov	r3, s15
70001dee:	623b      	str	r3, [r7, #32]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
70001df0:	e005      	b.n	70001dfe <HAL_RCC_GetSysClockFreq+0x286>
        sysclockfreq = 0U;
70001df2:	2300      	movs	r3, #0
70001df4:	623b      	str	r3, [r7, #32]
      break;
70001df6:	e002      	b.n	70001dfe <HAL_RCC_GetSysClockFreq+0x286>

    default:
      sysclockfreq = CSI_VALUE;
70001df8:	4b0d      	ldr	r3, [pc, #52]	@ (70001e30 <HAL_RCC_GetSysClockFreq+0x2b8>)
70001dfa:	623b      	str	r3, [r7, #32]
      break;
70001dfc:	bf00      	nop
  }

  prescaler = RCC->CDCFGR & RCC_CDCFGR_CPRE;
70001dfe:	4b0a      	ldr	r3, [pc, #40]	@ (70001e28 <HAL_RCC_GetSysClockFreq+0x2b0>)
70001e00:	699b      	ldr	r3, [r3, #24]
70001e02:	f003 030f 	and.w	r3, r3, #15
70001e06:	607b      	str	r3, [r7, #4]
  if (prescaler >= 8U)
70001e08:	687b      	ldr	r3, [r7, #4]
70001e0a:	2b07      	cmp	r3, #7
70001e0c:	d905      	bls.n	70001e1a <HAL_RCC_GetSysClockFreq+0x2a2>
  {
    sysclockfreq = sysclockfreq >> (prescaler - RCC_CDCFGR_CPRE_3 + 1U);
70001e0e:	687b      	ldr	r3, [r7, #4]
70001e10:	3b07      	subs	r3, #7
70001e12:	6a3a      	ldr	r2, [r7, #32]
70001e14:	fa22 f303 	lsr.w	r3, r2, r3
70001e18:	623b      	str	r3, [r7, #32]
  }

  return sysclockfreq;
70001e1a:	6a3b      	ldr	r3, [r7, #32]
}
70001e1c:	4618      	mov	r0, r3
70001e1e:	372c      	adds	r7, #44	@ 0x2c
70001e20:	46bd      	mov	sp, r7
70001e22:	f85d 7b04 	ldr.w	r7, [sp], #4
70001e26:	4770      	bx	lr
70001e28:	58024400 	.word	0x58024400
70001e2c:	03d09000 	.word	0x03d09000
70001e30:	003d0900 	.word	0x003d0900
70001e34:	016e3600 	.word	0x016e3600
70001e38:	46000000 	.word	0x46000000
70001e3c:	4a742400 	.word	0x4a742400
70001e40:	4bb71b00 	.word	0x4bb71b00

70001e44 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
70001e44:	b580      	push	{r7, lr}
70001e46:	b084      	sub	sp, #16
70001e48:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  const uint8_t AHBPrescTable[8] = {1U, 2U, 3U, 4U, 6U, 7U, 8U, 9U};
70001e4a:	4a10      	ldr	r2, [pc, #64]	@ (70001e8c <HAL_RCC_GetHCLKFreq+0x48>)
70001e4c:	463b      	mov	r3, r7
70001e4e:	e892 0003 	ldmia.w	r2, {r0, r1}
70001e52:	e883 0003 	stmia.w	r3, {r0, r1}

  /* SysClk */
  clock = HAL_RCC_GetSysClockFreq();
70001e56:	f7ff fe8f 	bl	70001b78 <HAL_RCC_GetSysClockFreq>
70001e5a:	60f8      	str	r0, [r7, #12]
  /* Bus matrix divider */
  prescaler = (RCC->BMCFGR & RCC_BMCFGR_BMPRE) >> RCC_BMCFGR_BMPRE_Pos;
70001e5c:	4b0c      	ldr	r3, [pc, #48]	@ (70001e90 <HAL_RCC_GetHCLKFreq+0x4c>)
70001e5e:	69db      	ldr	r3, [r3, #28]
70001e60:	f003 030f 	and.w	r3, r3, #15
70001e64:	60bb      	str	r3, [r7, #8]
  if (prescaler >= 8U)
70001e66:	68bb      	ldr	r3, [r7, #8]
70001e68:	2b07      	cmp	r3, #7
70001e6a:	d909      	bls.n	70001e80 <HAL_RCC_GetHCLKFreq+0x3c>
  {
    clock = clock >> AHBPrescTable[prescaler - 8U];
70001e6c:	68bb      	ldr	r3, [r7, #8]
70001e6e:	3b08      	subs	r3, #8
70001e70:	3310      	adds	r3, #16
70001e72:	443b      	add	r3, r7
70001e74:	f813 3c10 	ldrb.w	r3, [r3, #-16]
70001e78:	461a      	mov	r2, r3
70001e7a:	68fb      	ldr	r3, [r7, #12]
70001e7c:	40d3      	lsrs	r3, r2
70001e7e:	60fb      	str	r3, [r7, #12]
  }
  return (clock);
70001e80:	68fb      	ldr	r3, [r7, #12]
}
70001e82:	4618      	mov	r0, r3
70001e84:	3710      	adds	r7, #16
70001e86:	46bd      	mov	sp, r7
70001e88:	bd80      	pop	{r7, pc}
70001e8a:	bf00      	nop
70001e8c:	70002e2c 	.word	0x70002e2c
70001e90:	58024400 	.word	0x58024400

70001e94 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
70001e94:	b580      	push	{r7, lr}
70001e96:	b082      	sub	sp, #8
70001e98:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK1 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
70001e9a:	f7ff ffd3 	bl	70001e44 <HAL_RCC_GetHCLKFreq>
70001e9e:	6078      	str	r0, [r7, #4]
  /* APB1 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE1) >> RCC_APBCFGR_PPRE1_Pos;
70001ea0:	4b09      	ldr	r3, [pc, #36]	@ (70001ec8 <HAL_RCC_GetPCLK1Freq+0x34>)
70001ea2:	6a1b      	ldr	r3, [r3, #32]
70001ea4:	f003 0307 	and.w	r3, r3, #7
70001ea8:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
70001eaa:	683b      	ldr	r3, [r7, #0]
70001eac:	2b03      	cmp	r3, #3
70001eae:	d905      	bls.n	70001ebc <HAL_RCC_GetPCLK1Freq+0x28>
  {
    clock = clock >> (prescaler - 3U);
70001eb0:	683b      	ldr	r3, [r7, #0]
70001eb2:	3b03      	subs	r3, #3
70001eb4:	687a      	ldr	r2, [r7, #4]
70001eb6:	fa22 f303 	lsr.w	r3, r2, r3
70001eba:	607b      	str	r3, [r7, #4]
  }
  return (clock);
70001ebc:	687b      	ldr	r3, [r7, #4]
}
70001ebe:	4618      	mov	r0, r3
70001ec0:	3708      	adds	r7, #8
70001ec2:	46bd      	mov	sp, r7
70001ec4:	bd80      	pop	{r7, pc}
70001ec6:	bf00      	nop
70001ec8:	58024400 	.word	0x58024400

70001ecc <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
70001ecc:	b580      	push	{r7, lr}
70001ece:	b082      	sub	sp, #8
70001ed0:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK2 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
70001ed2:	f7ff ffb7 	bl	70001e44 <HAL_RCC_GetHCLKFreq>
70001ed6:	6078      	str	r0, [r7, #4]
  /* APB2 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE2) >> RCC_APBCFGR_PPRE2_Pos;
70001ed8:	4b09      	ldr	r3, [pc, #36]	@ (70001f00 <HAL_RCC_GetPCLK2Freq+0x34>)
70001eda:	6a1b      	ldr	r3, [r3, #32]
70001edc:	091b      	lsrs	r3, r3, #4
70001ede:	f003 0307 	and.w	r3, r3, #7
70001ee2:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
70001ee4:	683b      	ldr	r3, [r7, #0]
70001ee6:	2b03      	cmp	r3, #3
70001ee8:	d905      	bls.n	70001ef6 <HAL_RCC_GetPCLK2Freq+0x2a>
  {
    clock = clock >> (prescaler - 3U);
70001eea:	683b      	ldr	r3, [r7, #0]
70001eec:	3b03      	subs	r3, #3
70001eee:	687a      	ldr	r2, [r7, #4]
70001ef0:	fa22 f303 	lsr.w	r3, r2, r3
70001ef4:	607b      	str	r3, [r7, #4]
  }
  return (clock);
70001ef6:	687b      	ldr	r3, [r7, #4]
}
70001ef8:	4618      	mov	r0, r3
70001efa:	3708      	adds	r7, #8
70001efc:	46bd      	mov	sp, r7
70001efe:	bd80      	pop	{r7, pc}
70001f00:	58024400 	.word	0x58024400

70001f04 <HAL_RCC_GetPCLK4Freq>:
  * @note   Each time PCLK4 changes, this function must be called to update the
  *         right PCLK4 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK4 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK4Freq(void)
{
70001f04:	b580      	push	{r7, lr}
70001f06:	b082      	sub	sp, #8
70001f08:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK4 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
70001f0a:	f7ff ff9b 	bl	70001e44 <HAL_RCC_GetHCLKFreq>
70001f0e:	6078      	str	r0, [r7, #4]
  /* APB4 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE4) >> RCC_APBCFGR_PPRE4_Pos;
70001f10:	4b09      	ldr	r3, [pc, #36]	@ (70001f38 <HAL_RCC_GetPCLK4Freq+0x34>)
70001f12:	6a1b      	ldr	r3, [r3, #32]
70001f14:	0a1b      	lsrs	r3, r3, #8
70001f16:	f003 0307 	and.w	r3, r3, #7
70001f1a:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
70001f1c:	683b      	ldr	r3, [r7, #0]
70001f1e:	2b03      	cmp	r3, #3
70001f20:	d905      	bls.n	70001f2e <HAL_RCC_GetPCLK4Freq+0x2a>
  {
    clock = clock >> (prescaler - 3U);
70001f22:	683b      	ldr	r3, [r7, #0]
70001f24:	3b03      	subs	r3, #3
70001f26:	687a      	ldr	r2, [r7, #4]
70001f28:	fa22 f303 	lsr.w	r3, r2, r3
70001f2c:	607b      	str	r3, [r7, #4]
  }
  return (clock);
70001f2e:	687b      	ldr	r3, [r7, #4]
}
70001f30:	4618      	mov	r0, r3
70001f32:	3708      	adds	r7, #8
70001f34:	46bd      	mov	sp, r7
70001f36:	bd80      	pop	{r7, pc}
70001f38:	58024400 	.word	0x58024400

70001f3c <HAL_RCC_GetPLL2QFreq>:
/**
  * @brief  Return the PLL2Q frequency.
  * @retval PLL2Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2QFreq(void)
{
70001f3c:	b580      	push	{r7, lr}
70001f3e:	b082      	sub	sp, #8
70001f40:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL2Q divider */
  pllq = ((RCC->PLL2DIVR1 & RCC_PLL2DIVR1_DIVQ) >> RCC_PLL2DIVR1_DIVQ_Pos) + 1U;
70001f42:	4b08      	ldr	r3, [pc, #32]	@ (70001f64 <HAL_RCC_GetPLL2QFreq+0x28>)
70001f44:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70001f46:	0c1b      	lsrs	r3, r3, #16
70001f48:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
70001f4c:	3301      	adds	r3, #1
70001f4e:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2Q one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllq);
70001f50:	f000 f820 	bl	70001f94 <RCC_PLL2_GetVCOOutputFreq>
70001f54:	4602      	mov	r2, r0
70001f56:	687b      	ldr	r3, [r7, #4]
70001f58:	fbb2 f3f3 	udiv	r3, r2, r3
}
70001f5c:	4618      	mov	r0, r3
70001f5e:	3708      	adds	r7, #8
70001f60:	46bd      	mov	sp, r7
70001f62:	bd80      	pop	{r7, pc}
70001f64:	58024400 	.word	0x58024400

70001f68 <HAL_RCC_GetPLL3QFreq>:
/**
  * @brief  Return the PLL3Q frequency.
  * @retval PLL3Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3QFreq(void)
{
70001f68:	b580      	push	{r7, lr}
70001f6a:	b082      	sub	sp, #8
70001f6c:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL3Q divider */
  pllq = ((RCC->PLL3DIVR1 & RCC_PLL3DIVR1_DIVQ) >> RCC_PLL3DIVR1_DIVQ_Pos) + 1U;
70001f6e:	4b08      	ldr	r3, [pc, #32]	@ (70001f90 <HAL_RCC_GetPLL3QFreq+0x28>)
70001f70:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70001f72:	0c1b      	lsrs	r3, r3, #16
70001f74:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
70001f78:	3301      	adds	r3, #1
70001f7a:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3Q one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / pllq);
70001f7c:	f000 f890 	bl	700020a0 <RCC_PLL3_GetVCOOutputFreq>
70001f80:	4602      	mov	r2, r0
70001f82:	687b      	ldr	r3, [r7, #4]
70001f84:	fbb2 f3f3 	udiv	r3, r2, r3
}
70001f88:	4618      	mov	r0, r3
70001f8a:	3708      	adds	r7, #8
70001f8c:	46bd      	mov	sp, r7
70001f8e:	bd80      	pop	{r7, pc}
70001f90:	58024400 	.word	0x58024400

70001f94 <RCC_PLL2_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL2 VCO output frequency
  * @retval Value of PLL2 VCO output frequency
  */
static uint32_t RCC_PLL2_GetVCOOutputFreq(void)
{
70001f94:	b480      	push	{r7}
70001f96:	b089      	sub	sp, #36	@ 0x24
70001f98:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL2 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
70001f9a:	4b3c      	ldr	r3, [pc, #240]	@ (7000208c <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70001f9c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70001f9e:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL2DIVR1;
70001fa0:	4b3a      	ldr	r3, [pc, #232]	@ (7000208c <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70001fa2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70001fa4:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL2 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM2) >> RCC_PLLCKSELR_DIVM2_Pos;
70001fa6:	697b      	ldr	r3, [r7, #20]
70001fa8:	0b1b      	lsrs	r3, r3, #12
70001faa:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70001fae:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL2DIVR1_DIVN) + 1U;
70001fb0:	693b      	ldr	r3, [r7, #16]
70001fb2:	f3c3 0308 	ubfx	r3, r3, #0, #9
70001fb6:	3301      	adds	r3, #1
70001fb8:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
70001fba:	68fb      	ldr	r3, [r7, #12]
70001fbc:	2b00      	cmp	r3, #0
70001fbe:	d101      	bne.n	70001fc4 <RCC_PLL2_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
70001fc0:	2300      	movs	r3, #0
70001fc2:	e05c      	b.n	7000207e <RCC_PLL2_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) != 0U)
70001fc4:	4b31      	ldr	r3, [pc, #196]	@ (7000208c <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70001fc6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70001fc8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
70001fcc:	2b00      	cmp	r3, #0
70001fce:	d006      	beq.n	70001fde <RCC_PLL2_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN) >> RCC_PLL2FRACR_FRACN_Pos;
70001fd0:	4b2e      	ldr	r3, [pc, #184]	@ (7000208c <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70001fd2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
70001fd4:	08db      	lsrs	r3, r3, #3
70001fd6:	f3c3 030c 	ubfx	r3, r3, #0, #13
70001fda:	61bb      	str	r3, [r7, #24]
70001fdc:	e001      	b.n	70001fe2 <RCC_PLL2_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
70001fde:	2300      	movs	r3, #0
70001fe0:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
70001fe2:	697b      	ldr	r3, [r7, #20]
70001fe4:	f003 0303 	and.w	r3, r3, #3
70001fe8:	2b02      	cmp	r3, #2
70001fea:	d019      	beq.n	70002020 <RCC_PLL2_GetVCOOutputFreq+0x8c>
70001fec:	2b02      	cmp	r3, #2
70001fee:	d81d      	bhi.n	7000202c <RCC_PLL2_GetVCOOutputFreq+0x98>
70001ff0:	2b00      	cmp	r3, #0
70001ff2:	d002      	beq.n	70001ffa <RCC_PLL2_GetVCOOutputFreq+0x66>
70001ff4:	2b01      	cmp	r3, #1
70001ff6:	d016      	beq.n	70002026 <RCC_PLL2_GetVCOOutputFreq+0x92>
70001ff8:	e018      	b.n	7000202c <RCC_PLL2_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL2 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70001ffa:	4b24      	ldr	r3, [pc, #144]	@ (7000208c <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70001ffc:	681b      	ldr	r3, [r3, #0]
70001ffe:	f003 0320 	and.w	r3, r3, #32
70002002:	2b00      	cmp	r3, #0
70002004:	d009      	beq.n	7000201a <RCC_PLL2_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
70002006:	4b21      	ldr	r3, [pc, #132]	@ (7000208c <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70002008:	681b      	ldr	r3, [r3, #0]
7000200a:	08db      	lsrs	r3, r3, #3
7000200c:	f003 0303 	and.w	r3, r3, #3
70002010:	4a1f      	ldr	r2, [pc, #124]	@ (70002090 <RCC_PLL2_GetVCOOutputFreq+0xfc>)
70002012:	fa22 f303 	lsr.w	r3, r2, r3
70002016:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
70002018:	e00b      	b.n	70002032 <RCC_PLL2_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
7000201a:	2300      	movs	r3, #0
7000201c:	61fb      	str	r3, [r7, #28]
      break;
7000201e:	e008      	b.n	70002032 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL2 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
70002020:	4b1c      	ldr	r3, [pc, #112]	@ (70002094 <RCC_PLL2_GetVCOOutputFreq+0x100>)
70002022:	61fb      	str	r3, [r7, #28]
      break;
70002024:	e005      	b.n	70002032 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL2 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
70002026:	4b1c      	ldr	r3, [pc, #112]	@ (70002098 <RCC_PLL2_GetVCOOutputFreq+0x104>)
70002028:	61fb      	str	r3, [r7, #28]
      break;
7000202a:	e002      	b.n	70002032 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
7000202c:	2300      	movs	r3, #0
7000202e:	61fb      	str	r3, [r7, #28]
      break;
70002030:	bf00      	nop
  }

  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
70002032:	69fb      	ldr	r3, [r7, #28]
70002034:	ee07 3a90 	vmov	s15, r3
70002038:	eef8 6a67 	vcvt.f32.u32	s13, s15
7000203c:	68fb      	ldr	r3, [r7, #12]
7000203e:	ee07 3a90 	vmov	s15, r3
70002042:	eef8 7a67 	vcvt.f32.u32	s15, s15
70002046:	ee86 7aa7 	vdiv.f32	s14, s13, s15
7000204a:	68bb      	ldr	r3, [r7, #8]
7000204c:	ee07 3a90 	vmov	s15, r3
70002050:	eef8 6a67 	vcvt.f32.u32	s13, s15
70002054:	69bb      	ldr	r3, [r7, #24]
70002056:	ee07 3a90 	vmov	s15, r3
7000205a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
7000205e:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 7000209c <RCC_PLL2_GetVCOOutputFreq+0x108>
70002062:	eec6 7a25 	vdiv.f32	s15, s12, s11
70002066:	ee76 7aa7 	vadd.f32	s15, s13, s15
7000206a:	ee67 7a27 	vmul.f32	s15, s14, s15
7000206e:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
70002072:	edd7 7a01 	vldr	s15, [r7, #4]
70002076:	eefc 7ae7 	vcvt.u32.f32	s15, s15
7000207a:	ee17 3a90 	vmov	r3, s15
}
7000207e:	4618      	mov	r0, r3
70002080:	3724      	adds	r7, #36	@ 0x24
70002082:	46bd      	mov	sp, r7
70002084:	f85d 7b04 	ldr.w	r7, [sp], #4
70002088:	4770      	bx	lr
7000208a:	bf00      	nop
7000208c:	58024400 	.word	0x58024400
70002090:	03d09000 	.word	0x03d09000
70002094:	016e3600 	.word	0x016e3600
70002098:	003d0900 	.word	0x003d0900
7000209c:	46000000 	.word	0x46000000

700020a0 <RCC_PLL3_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL3 VCO output frequency
  * @retval Value of PLL3 VCO output frequency
  */
static uint32_t RCC_PLL3_GetVCOOutputFreq(void)
{
700020a0:	b480      	push	{r7}
700020a2:	b089      	sub	sp, #36	@ 0x24
700020a4:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL3 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
700020a6:	4b3c      	ldr	r3, [pc, #240]	@ (70002198 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
700020a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700020aa:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL3DIVR1;
700020ac:	4b3a      	ldr	r3, [pc, #232]	@ (70002198 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
700020ae:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
700020b0:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL3 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM3) >> RCC_PLLCKSELR_DIVM3_Pos;
700020b2:	697b      	ldr	r3, [r7, #20]
700020b4:	0d1b      	lsrs	r3, r3, #20
700020b6:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
700020ba:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL3DIVR1_DIVN) + 1U;
700020bc:	693b      	ldr	r3, [r7, #16]
700020be:	f3c3 0308 	ubfx	r3, r3, #0, #9
700020c2:	3301      	adds	r3, #1
700020c4:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
700020c6:	68fb      	ldr	r3, [r7, #12]
700020c8:	2b00      	cmp	r3, #0
700020ca:	d101      	bne.n	700020d0 <RCC_PLL3_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
700020cc:	2300      	movs	r3, #0
700020ce:	e05c      	b.n	7000218a <RCC_PLL3_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) != 0U)
700020d0:	4b31      	ldr	r3, [pc, #196]	@ (70002198 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
700020d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700020d4:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
700020d8:	2b00      	cmp	r3, #0
700020da:	d006      	beq.n	700020ea <RCC_PLL3_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN) >> RCC_PLL3FRACR_FRACN_Pos;
700020dc:	4b2e      	ldr	r3, [pc, #184]	@ (70002198 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
700020de:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
700020e0:	08db      	lsrs	r3, r3, #3
700020e2:	f3c3 030c 	ubfx	r3, r3, #0, #13
700020e6:	61bb      	str	r3, [r7, #24]
700020e8:	e001      	b.n	700020ee <RCC_PLL3_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
700020ea:	2300      	movs	r3, #0
700020ec:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
700020ee:	697b      	ldr	r3, [r7, #20]
700020f0:	f003 0303 	and.w	r3, r3, #3
700020f4:	2b02      	cmp	r3, #2
700020f6:	d019      	beq.n	7000212c <RCC_PLL3_GetVCOOutputFreq+0x8c>
700020f8:	2b02      	cmp	r3, #2
700020fa:	d81d      	bhi.n	70002138 <RCC_PLL3_GetVCOOutputFreq+0x98>
700020fc:	2b00      	cmp	r3, #0
700020fe:	d002      	beq.n	70002106 <RCC_PLL3_GetVCOOutputFreq+0x66>
70002100:	2b01      	cmp	r3, #1
70002102:	d016      	beq.n	70002132 <RCC_PLL3_GetVCOOutputFreq+0x92>
70002104:	e018      	b.n	70002138 <RCC_PLL3_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL3 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70002106:	4b24      	ldr	r3, [pc, #144]	@ (70002198 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
70002108:	681b      	ldr	r3, [r3, #0]
7000210a:	f003 0320 	and.w	r3, r3, #32
7000210e:	2b00      	cmp	r3, #0
70002110:	d009      	beq.n	70002126 <RCC_PLL3_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
70002112:	4b21      	ldr	r3, [pc, #132]	@ (70002198 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
70002114:	681b      	ldr	r3, [r3, #0]
70002116:	08db      	lsrs	r3, r3, #3
70002118:	f003 0303 	and.w	r3, r3, #3
7000211c:	4a1f      	ldr	r2, [pc, #124]	@ (7000219c <RCC_PLL3_GetVCOOutputFreq+0xfc>)
7000211e:	fa22 f303 	lsr.w	r3, r2, r3
70002122:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
70002124:	e00b      	b.n	7000213e <RCC_PLL3_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
70002126:	2300      	movs	r3, #0
70002128:	61fb      	str	r3, [r7, #28]
      break;
7000212a:	e008      	b.n	7000213e <RCC_PLL3_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL3 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
7000212c:	4b1c      	ldr	r3, [pc, #112]	@ (700021a0 <RCC_PLL3_GetVCOOutputFreq+0x100>)
7000212e:	61fb      	str	r3, [r7, #28]
      break;
70002130:	e005      	b.n	7000213e <RCC_PLL3_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL3 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
70002132:	4b1c      	ldr	r3, [pc, #112]	@ (700021a4 <RCC_PLL3_GetVCOOutputFreq+0x104>)
70002134:	61fb      	str	r3, [r7, #28]
      break;
70002136:	e002      	b.n	7000213e <RCC_PLL3_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
70002138:	2300      	movs	r3, #0
7000213a:	61fb      	str	r3, [r7, #28]
      break;
7000213c:	bf00      	nop
  }

  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
7000213e:	69fb      	ldr	r3, [r7, #28]
70002140:	ee07 3a90 	vmov	s15, r3
70002144:	eef8 6a67 	vcvt.f32.u32	s13, s15
70002148:	68fb      	ldr	r3, [r7, #12]
7000214a:	ee07 3a90 	vmov	s15, r3
7000214e:	eef8 7a67 	vcvt.f32.u32	s15, s15
70002152:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70002156:	68bb      	ldr	r3, [r7, #8]
70002158:	ee07 3a90 	vmov	s15, r3
7000215c:	eef8 6a67 	vcvt.f32.u32	s13, s15
70002160:	69bb      	ldr	r3, [r7, #24]
70002162:	ee07 3a90 	vmov	s15, r3
70002166:	eeb8 6a67 	vcvt.f32.u32	s12, s15
7000216a:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 700021a8 <RCC_PLL3_GetVCOOutputFreq+0x108>
7000216e:	eec6 7a25 	vdiv.f32	s15, s12, s11
70002172:	ee76 7aa7 	vadd.f32	s15, s13, s15
70002176:	ee67 7a27 	vmul.f32	s15, s14, s15
7000217a:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
7000217e:	edd7 7a01 	vldr	s15, [r7, #4]
70002182:	eefc 7ae7 	vcvt.u32.f32	s15, s15
70002186:	ee17 3a90 	vmov	r3, s15
}
7000218a:	4618      	mov	r0, r3
7000218c:	3724      	adds	r7, #36	@ 0x24
7000218e:	46bd      	mov	sp, r7
70002190:	f85d 7b04 	ldr.w	r7, [sp], #4
70002194:	4770      	bx	lr
70002196:	bf00      	nop
70002198:	58024400 	.word	0x58024400
7000219c:	03d09000 	.word	0x03d09000
700021a0:	016e3600 	.word	0x016e3600
700021a4:	003d0900 	.word	0x003d0900
700021a8:	46000000 	.word	0x46000000

700021ac <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
700021ac:	b580      	push	{r7, lr}
700021ae:	b082      	sub	sp, #8
700021b0:	af00      	add	r7, sp, #0
700021b2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
700021b4:	687b      	ldr	r3, [r7, #4]
700021b6:	2b00      	cmp	r3, #0
700021b8:	d101      	bne.n	700021be <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
700021ba:	2301      	movs	r3, #1
700021bc:	e042      	b.n	70002244 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
700021be:	687b      	ldr	r3, [r7, #4]
700021c0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
700021c4:	2b00      	cmp	r3, #0
700021c6:	d106      	bne.n	700021d6 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
700021c8:	687b      	ldr	r3, [r7, #4]
700021ca:	2200      	movs	r2, #0
700021cc:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
700021d0:	6878      	ldr	r0, [r7, #4]
700021d2:	f000 f83b 	bl	7000224c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
700021d6:	687b      	ldr	r3, [r7, #4]
700021d8:	2224      	movs	r2, #36	@ 0x24
700021da:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
700021de:	687b      	ldr	r3, [r7, #4]
700021e0:	681b      	ldr	r3, [r3, #0]
700021e2:	681a      	ldr	r2, [r3, #0]
700021e4:	687b      	ldr	r3, [r7, #4]
700021e6:	681b      	ldr	r3, [r3, #0]
700021e8:	f022 0201 	bic.w	r2, r2, #1
700021ec:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
700021ee:	687b      	ldr	r3, [r7, #4]
700021f0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700021f2:	2b00      	cmp	r3, #0
700021f4:	d002      	beq.n	700021fc <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
700021f6:	6878      	ldr	r0, [r7, #4]
700021f8:	f000 fbc8 	bl	7000298c <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
700021fc:	6878      	ldr	r0, [r7, #4]
700021fe:	f000 f82f 	bl	70002260 <UART_SetConfig>
70002202:	4603      	mov	r3, r0
70002204:	2b01      	cmp	r3, #1
70002206:	d101      	bne.n	7000220c <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
70002208:	2301      	movs	r3, #1
7000220a:	e01b      	b.n	70002244 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
7000220c:	687b      	ldr	r3, [r7, #4]
7000220e:	681b      	ldr	r3, [r3, #0]
70002210:	685a      	ldr	r2, [r3, #4]
70002212:	687b      	ldr	r3, [r7, #4]
70002214:	681b      	ldr	r3, [r3, #0]
70002216:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
7000221a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
7000221c:	687b      	ldr	r3, [r7, #4]
7000221e:	681b      	ldr	r3, [r3, #0]
70002220:	689a      	ldr	r2, [r3, #8]
70002222:	687b      	ldr	r3, [r7, #4]
70002224:	681b      	ldr	r3, [r3, #0]
70002226:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
7000222a:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
7000222c:	687b      	ldr	r3, [r7, #4]
7000222e:	681b      	ldr	r3, [r3, #0]
70002230:	681a      	ldr	r2, [r3, #0]
70002232:	687b      	ldr	r3, [r7, #4]
70002234:	681b      	ldr	r3, [r3, #0]
70002236:	f042 0201 	orr.w	r2, r2, #1
7000223a:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
7000223c:	6878      	ldr	r0, [r7, #4]
7000223e:	f000 fc47 	bl	70002ad0 <UART_CheckIdleState>
70002242:	4603      	mov	r3, r0
}
70002244:	4618      	mov	r0, r3
70002246:	3708      	adds	r7, #8
70002248:	46bd      	mov	sp, r7
7000224a:	bd80      	pop	{r7, pc}

7000224c <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
7000224c:	b480      	push	{r7}
7000224e:	b083      	sub	sp, #12
70002250:	af00      	add	r7, sp, #0
70002252:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
70002254:	bf00      	nop
70002256:	370c      	adds	r7, #12
70002258:	46bd      	mov	sp, r7
7000225a:	f85d 7b04 	ldr.w	r7, [sp], #4
7000225e:	4770      	bx	lr

70002260 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
70002260:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
70002264:	b08c      	sub	sp, #48	@ 0x30
70002266:	af00      	add	r7, sp, #0
70002268:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
7000226a:	2300      	movs	r3, #0
7000226c:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
70002270:	697b      	ldr	r3, [r7, #20]
70002272:	689a      	ldr	r2, [r3, #8]
70002274:	697b      	ldr	r3, [r7, #20]
70002276:	691b      	ldr	r3, [r3, #16]
70002278:	431a      	orrs	r2, r3
7000227a:	697b      	ldr	r3, [r7, #20]
7000227c:	695b      	ldr	r3, [r3, #20]
7000227e:	431a      	orrs	r2, r3
70002280:	697b      	ldr	r3, [r7, #20]
70002282:	69db      	ldr	r3, [r3, #28]
70002284:	4313      	orrs	r3, r2
70002286:	62fb      	str	r3, [r7, #44]	@ 0x2c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
70002288:	697b      	ldr	r3, [r7, #20]
7000228a:	681b      	ldr	r3, [r3, #0]
7000228c:	681a      	ldr	r2, [r3, #0]
7000228e:	4bb3      	ldr	r3, [pc, #716]	@ (7000255c <UART_SetConfig+0x2fc>)
70002290:	4013      	ands	r3, r2
70002292:	697a      	ldr	r2, [r7, #20]
70002294:	6812      	ldr	r2, [r2, #0]
70002296:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
70002298:	430b      	orrs	r3, r1
7000229a:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
7000229c:	697b      	ldr	r3, [r7, #20]
7000229e:	681b      	ldr	r3, [r3, #0]
700022a0:	685b      	ldr	r3, [r3, #4]
700022a2:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
700022a6:	697b      	ldr	r3, [r7, #20]
700022a8:	68da      	ldr	r2, [r3, #12]
700022aa:	697b      	ldr	r3, [r7, #20]
700022ac:	681b      	ldr	r3, [r3, #0]
700022ae:	430a      	orrs	r2, r1
700022b0:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
700022b2:	697b      	ldr	r3, [r7, #20]
700022b4:	699b      	ldr	r3, [r3, #24]
700022b6:	62fb      	str	r3, [r7, #44]	@ 0x2c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
700022b8:	697b      	ldr	r3, [r7, #20]
700022ba:	681b      	ldr	r3, [r3, #0]
700022bc:	4aa8      	ldr	r2, [pc, #672]	@ (70002560 <UART_SetConfig+0x300>)
700022be:	4293      	cmp	r3, r2
700022c0:	d004      	beq.n	700022cc <UART_SetConfig+0x6c>
  {
    tmpreg |= huart->Init.OneBitSampling;
700022c2:	697b      	ldr	r3, [r7, #20]
700022c4:	6a1b      	ldr	r3, [r3, #32]
700022c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
700022c8:	4313      	orrs	r3, r2
700022ca:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
700022cc:	697b      	ldr	r3, [r7, #20]
700022ce:	681b      	ldr	r3, [r3, #0]
700022d0:	689a      	ldr	r2, [r3, #8]
700022d2:	4ba4      	ldr	r3, [pc, #656]	@ (70002564 <UART_SetConfig+0x304>)
700022d4:	4013      	ands	r3, r2
700022d6:	697a      	ldr	r2, [r7, #20]
700022d8:	6812      	ldr	r2, [r2, #0]
700022da:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
700022dc:	430b      	orrs	r3, r1
700022de:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
700022e0:	697b      	ldr	r3, [r7, #20]
700022e2:	681b      	ldr	r3, [r3, #0]
700022e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700022e6:	f023 010f 	bic.w	r1, r3, #15
700022ea:	697b      	ldr	r3, [r7, #20]
700022ec:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
700022ee:	697b      	ldr	r3, [r7, #20]
700022f0:	681b      	ldr	r3, [r3, #0]
700022f2:	430a      	orrs	r2, r1
700022f4:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
700022f6:	697b      	ldr	r3, [r7, #20]
700022f8:	681b      	ldr	r3, [r3, #0]
700022fa:	4a9b      	ldr	r2, [pc, #620]	@ (70002568 <UART_SetConfig+0x308>)
700022fc:	4293      	cmp	r3, r2
700022fe:	d131      	bne.n	70002364 <UART_SetConfig+0x104>
70002300:	4b9a      	ldr	r3, [pc, #616]	@ (7000256c <UART_SetConfig+0x30c>)
70002302:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70002304:	f003 0307 	and.w	r3, r3, #7
70002308:	2b05      	cmp	r3, #5
7000230a:	d827      	bhi.n	7000235c <UART_SetConfig+0xfc>
7000230c:	a201      	add	r2, pc, #4	@ (adr r2, 70002314 <UART_SetConfig+0xb4>)
7000230e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70002312:	bf00      	nop
70002314:	7000232d 	.word	0x7000232d
70002318:	70002335 	.word	0x70002335
7000231c:	7000233d 	.word	0x7000233d
70002320:	70002345 	.word	0x70002345
70002324:	7000234d 	.word	0x7000234d
70002328:	70002355 	.word	0x70002355
7000232c:	2301      	movs	r3, #1
7000232e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002332:	e0a0      	b.n	70002476 <UART_SetConfig+0x216>
70002334:	2304      	movs	r3, #4
70002336:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000233a:	e09c      	b.n	70002476 <UART_SetConfig+0x216>
7000233c:	2308      	movs	r3, #8
7000233e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002342:	e098      	b.n	70002476 <UART_SetConfig+0x216>
70002344:	2310      	movs	r3, #16
70002346:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000234a:	e094      	b.n	70002476 <UART_SetConfig+0x216>
7000234c:	2320      	movs	r3, #32
7000234e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002352:	e090      	b.n	70002476 <UART_SetConfig+0x216>
70002354:	2340      	movs	r3, #64	@ 0x40
70002356:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000235a:	e08c      	b.n	70002476 <UART_SetConfig+0x216>
7000235c:	2380      	movs	r3, #128	@ 0x80
7000235e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002362:	e088      	b.n	70002476 <UART_SetConfig+0x216>
70002364:	697b      	ldr	r3, [r7, #20]
70002366:	681b      	ldr	r3, [r3, #0]
70002368:	4a81      	ldr	r2, [pc, #516]	@ (70002570 <UART_SetConfig+0x310>)
7000236a:	4293      	cmp	r3, r2
7000236c:	d018      	beq.n	700023a0 <UART_SetConfig+0x140>
7000236e:	697b      	ldr	r3, [r7, #20]
70002370:	681b      	ldr	r3, [r3, #0]
70002372:	4a80      	ldr	r2, [pc, #512]	@ (70002574 <UART_SetConfig+0x314>)
70002374:	4293      	cmp	r3, r2
70002376:	d013      	beq.n	700023a0 <UART_SetConfig+0x140>
70002378:	697b      	ldr	r3, [r7, #20]
7000237a:	681b      	ldr	r3, [r3, #0]
7000237c:	4a7e      	ldr	r2, [pc, #504]	@ (70002578 <UART_SetConfig+0x318>)
7000237e:	4293      	cmp	r3, r2
70002380:	d00e      	beq.n	700023a0 <UART_SetConfig+0x140>
70002382:	697b      	ldr	r3, [r7, #20]
70002384:	681b      	ldr	r3, [r3, #0]
70002386:	4a7d      	ldr	r2, [pc, #500]	@ (7000257c <UART_SetConfig+0x31c>)
70002388:	4293      	cmp	r3, r2
7000238a:	d009      	beq.n	700023a0 <UART_SetConfig+0x140>
7000238c:	697b      	ldr	r3, [r7, #20]
7000238e:	681b      	ldr	r3, [r3, #0]
70002390:	4a7b      	ldr	r2, [pc, #492]	@ (70002580 <UART_SetConfig+0x320>)
70002392:	4293      	cmp	r3, r2
70002394:	d004      	beq.n	700023a0 <UART_SetConfig+0x140>
70002396:	697b      	ldr	r3, [r7, #20]
70002398:	681b      	ldr	r3, [r3, #0]
7000239a:	4a7a      	ldr	r2, [pc, #488]	@ (70002584 <UART_SetConfig+0x324>)
7000239c:	4293      	cmp	r3, r2
7000239e:	d131      	bne.n	70002404 <UART_SetConfig+0x1a4>
700023a0:	4b72      	ldr	r3, [pc, #456]	@ (7000256c <UART_SetConfig+0x30c>)
700023a2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
700023a4:	f003 0307 	and.w	r3, r3, #7
700023a8:	2b05      	cmp	r3, #5
700023aa:	d827      	bhi.n	700023fc <UART_SetConfig+0x19c>
700023ac:	a201      	add	r2, pc, #4	@ (adr r2, 700023b4 <UART_SetConfig+0x154>)
700023ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
700023b2:	bf00      	nop
700023b4:	700023cd 	.word	0x700023cd
700023b8:	700023d5 	.word	0x700023d5
700023bc:	700023dd 	.word	0x700023dd
700023c0:	700023e5 	.word	0x700023e5
700023c4:	700023ed 	.word	0x700023ed
700023c8:	700023f5 	.word	0x700023f5
700023cc:	2300      	movs	r3, #0
700023ce:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
700023d2:	e016      	b.n	70002402 <UART_SetConfig+0x1a2>
700023d4:	2304      	movs	r3, #4
700023d6:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
700023da:	e012      	b.n	70002402 <UART_SetConfig+0x1a2>
700023dc:	2308      	movs	r3, #8
700023de:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
700023e2:	e00e      	b.n	70002402 <UART_SetConfig+0x1a2>
700023e4:	2310      	movs	r3, #16
700023e6:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
700023ea:	e00a      	b.n	70002402 <UART_SetConfig+0x1a2>
700023ec:	2320      	movs	r3, #32
700023ee:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
700023f2:	e006      	b.n	70002402 <UART_SetConfig+0x1a2>
700023f4:	2340      	movs	r3, #64	@ 0x40
700023f6:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
700023fa:	e002      	b.n	70002402 <UART_SetConfig+0x1a2>
700023fc:	2380      	movs	r3, #128	@ 0x80
700023fe:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002402:	e038      	b.n	70002476 <UART_SetConfig+0x216>
70002404:	697b      	ldr	r3, [r7, #20]
70002406:	681b      	ldr	r3, [r3, #0]
70002408:	4a55      	ldr	r2, [pc, #340]	@ (70002560 <UART_SetConfig+0x300>)
7000240a:	4293      	cmp	r3, r2
7000240c:	d130      	bne.n	70002470 <UART_SetConfig+0x210>
7000240e:	4b57      	ldr	r3, [pc, #348]	@ (7000256c <UART_SetConfig+0x30c>)
70002410:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
70002412:	f003 0307 	and.w	r3, r3, #7
70002416:	2b05      	cmp	r3, #5
70002418:	d826      	bhi.n	70002468 <UART_SetConfig+0x208>
7000241a:	a201      	add	r2, pc, #4	@ (adr r2, 70002420 <UART_SetConfig+0x1c0>)
7000241c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70002420:	70002439 	.word	0x70002439
70002424:	70002441 	.word	0x70002441
70002428:	70002449 	.word	0x70002449
7000242c:	70002451 	.word	0x70002451
70002430:	70002459 	.word	0x70002459
70002434:	70002461 	.word	0x70002461
70002438:	2302      	movs	r3, #2
7000243a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000243e:	e01a      	b.n	70002476 <UART_SetConfig+0x216>
70002440:	2304      	movs	r3, #4
70002442:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002446:	e016      	b.n	70002476 <UART_SetConfig+0x216>
70002448:	2308      	movs	r3, #8
7000244a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000244e:	e012      	b.n	70002476 <UART_SetConfig+0x216>
70002450:	2310      	movs	r3, #16
70002452:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002456:	e00e      	b.n	70002476 <UART_SetConfig+0x216>
70002458:	2320      	movs	r3, #32
7000245a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000245e:	e00a      	b.n	70002476 <UART_SetConfig+0x216>
70002460:	2340      	movs	r3, #64	@ 0x40
70002462:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70002466:	e006      	b.n	70002476 <UART_SetConfig+0x216>
70002468:	2380      	movs	r3, #128	@ 0x80
7000246a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000246e:	e002      	b.n	70002476 <UART_SetConfig+0x216>
70002470:	2380      	movs	r3, #128	@ 0x80
70002472:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
70002476:	697b      	ldr	r3, [r7, #20]
70002478:	681b      	ldr	r3, [r3, #0]
7000247a:	4a39      	ldr	r2, [pc, #228]	@ (70002560 <UART_SetConfig+0x300>)
7000247c:	4293      	cmp	r3, r2
7000247e:	f040 80fe 	bne.w	7000267e <UART_SetConfig+0x41e>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
70002482:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
70002486:	2b20      	cmp	r3, #32
70002488:	dc48      	bgt.n	7000251c <UART_SetConfig+0x2bc>
7000248a:	2b02      	cmp	r3, #2
7000248c:	f2c0 8088 	blt.w	700025a0 <UART_SetConfig+0x340>
70002490:	3b02      	subs	r3, #2
70002492:	2b1e      	cmp	r3, #30
70002494:	f200 8084 	bhi.w	700025a0 <UART_SetConfig+0x340>
70002498:	a201      	add	r2, pc, #4	@ (adr r2, 700024a0 <UART_SetConfig+0x240>)
7000249a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
7000249e:	bf00      	nop
700024a0:	70002533 	.word	0x70002533
700024a4:	700025a1 	.word	0x700025a1
700024a8:	70002523 	.word	0x70002523
700024ac:	700025a1 	.word	0x700025a1
700024b0:	700025a1 	.word	0x700025a1
700024b4:	700025a1 	.word	0x700025a1
700024b8:	7000252b 	.word	0x7000252b
700024bc:	700025a1 	.word	0x700025a1
700024c0:	700025a1 	.word	0x700025a1
700024c4:	700025a1 	.word	0x700025a1
700024c8:	700025a1 	.word	0x700025a1
700024cc:	700025a1 	.word	0x700025a1
700024d0:	700025a1 	.word	0x700025a1
700024d4:	700025a1 	.word	0x700025a1
700024d8:	7000253b 	.word	0x7000253b
700024dc:	700025a1 	.word	0x700025a1
700024e0:	700025a1 	.word	0x700025a1
700024e4:	700025a1 	.word	0x700025a1
700024e8:	700025a1 	.word	0x700025a1
700024ec:	700025a1 	.word	0x700025a1
700024f0:	700025a1 	.word	0x700025a1
700024f4:	700025a1 	.word	0x700025a1
700024f8:	700025a1 	.word	0x700025a1
700024fc:	700025a1 	.word	0x700025a1
70002500:	700025a1 	.word	0x700025a1
70002504:	700025a1 	.word	0x700025a1
70002508:	700025a1 	.word	0x700025a1
7000250c:	700025a1 	.word	0x700025a1
70002510:	700025a1 	.word	0x700025a1
70002514:	700025a1 	.word	0x700025a1
70002518:	70002593 	.word	0x70002593
7000251c:	2b40      	cmp	r3, #64	@ 0x40
7000251e:	d03b      	beq.n	70002598 <UART_SetConfig+0x338>
70002520:	e03e      	b.n	700025a0 <UART_SetConfig+0x340>
    {
      case UART_CLOCKSOURCE_PLL2Q:
        pclk = HAL_RCC_GetPLL2QFreq();
70002522:	f7ff fd0b 	bl	70001f3c <HAL_RCC_GetPLL2QFreq>
70002526:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70002528:	e040      	b.n	700025ac <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_PLL3Q:
        pclk = HAL_RCC_GetPLL3QFreq();
7000252a:	f7ff fd1d 	bl	70001f68 <HAL_RCC_GetPLL3QFreq>
7000252e:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70002530:	e03c      	b.n	700025ac <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_PCLK4:
        pclk = HAL_RCC_GetPCLK4Freq();
70002532:	f7ff fce7 	bl	70001f04 <HAL_RCC_GetPCLK4Freq>
70002536:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70002538:	e038      	b.n	700025ac <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
7000253a:	4b0c      	ldr	r3, [pc, #48]	@ (7000256c <UART_SetConfig+0x30c>)
7000253c:	681b      	ldr	r3, [r3, #0]
7000253e:	f003 0320 	and.w	r3, r3, #32
70002542:	2b00      	cmp	r3, #0
70002544:	d022      	beq.n	7000258c <UART_SetConfig+0x32c>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
70002546:	4b09      	ldr	r3, [pc, #36]	@ (7000256c <UART_SetConfig+0x30c>)
70002548:	681b      	ldr	r3, [r3, #0]
7000254a:	08db      	lsrs	r3, r3, #3
7000254c:	f003 0303 	and.w	r3, r3, #3
70002550:	4a0d      	ldr	r2, [pc, #52]	@ (70002588 <UART_SetConfig+0x328>)
70002552:	fa22 f303 	lsr.w	r3, r2, r3
70002556:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
70002558:	e028      	b.n	700025ac <UART_SetConfig+0x34c>
7000255a:	bf00      	nop
7000255c:	cfff69f3 	.word	0xcfff69f3
70002560:	58000c00 	.word	0x58000c00
70002564:	11fff4ff 	.word	0x11fff4ff
70002568:	42001000 	.word	0x42001000
7000256c:	58024400 	.word	0x58024400
70002570:	40004400 	.word	0x40004400
70002574:	40004800 	.word	0x40004800
70002578:	40004c00 	.word	0x40004c00
7000257c:	40005000 	.word	0x40005000
70002580:	40007800 	.word	0x40007800
70002584:	40007c00 	.word	0x40007c00
70002588:	03d09000 	.word	0x03d09000
          pclk = (uint32_t) HSI_VALUE;
7000258c:	4b99      	ldr	r3, [pc, #612]	@ (700027f4 <UART_SetConfig+0x594>)
7000258e:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
70002590:	e00c      	b.n	700025ac <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
70002592:	4b99      	ldr	r3, [pc, #612]	@ (700027f8 <UART_SetConfig+0x598>)
70002594:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
70002596:	e009      	b.n	700025ac <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
70002598:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
7000259c:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
7000259e:	e005      	b.n	700025ac <UART_SetConfig+0x34c>
      default:
        pclk = 0U;
700025a0:	2300      	movs	r3, #0
700025a2:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = HAL_ERROR;
700025a4:	2301      	movs	r3, #1
700025a6:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
        break;
700025aa:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
700025ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700025ae:	2b00      	cmp	r3, #0
700025b0:	f000 81ce 	beq.w	70002950 <UART_SetConfig+0x6f0>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
700025b4:	697b      	ldr	r3, [r7, #20]
700025b6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
700025b8:	4a90      	ldr	r2, [pc, #576]	@ (700027fc <UART_SetConfig+0x59c>)
700025ba:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700025be:	461a      	mov	r2, r3
700025c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700025c2:	fbb3 f3f2 	udiv	r3, r3, r2
700025c6:	61bb      	str	r3, [r7, #24]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
700025c8:	697b      	ldr	r3, [r7, #20]
700025ca:	685a      	ldr	r2, [r3, #4]
700025cc:	4613      	mov	r3, r2
700025ce:	005b      	lsls	r3, r3, #1
700025d0:	4413      	add	r3, r2
700025d2:	69ba      	ldr	r2, [r7, #24]
700025d4:	429a      	cmp	r2, r3
700025d6:	d305      	bcc.n	700025e4 <UART_SetConfig+0x384>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
700025d8:	697b      	ldr	r3, [r7, #20]
700025da:	685b      	ldr	r3, [r3, #4]
700025dc:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
700025de:	69ba      	ldr	r2, [r7, #24]
700025e0:	429a      	cmp	r2, r3
700025e2:	d903      	bls.n	700025ec <UART_SetConfig+0x38c>
      {
        ret = HAL_ERROR;
700025e4:	2301      	movs	r3, #1
700025e6:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
700025ea:	e1b1      	b.n	70002950 <UART_SetConfig+0x6f0>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
700025ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700025ee:	2200      	movs	r2, #0
700025f0:	60bb      	str	r3, [r7, #8]
700025f2:	60fa      	str	r2, [r7, #12]
700025f4:	697b      	ldr	r3, [r7, #20]
700025f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
700025f8:	4a80      	ldr	r2, [pc, #512]	@ (700027fc <UART_SetConfig+0x59c>)
700025fa:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700025fe:	b29b      	uxth	r3, r3
70002600:	2200      	movs	r2, #0
70002602:	603b      	str	r3, [r7, #0]
70002604:	607a      	str	r2, [r7, #4]
70002606:	e9d7 2300 	ldrd	r2, r3, [r7]
7000260a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
7000260e:	f7fd fe6f 	bl	700002f0 <__aeabi_uldivmod>
70002612:	4602      	mov	r2, r0
70002614:	460b      	mov	r3, r1
70002616:	4610      	mov	r0, r2
70002618:	4619      	mov	r1, r3
7000261a:	f04f 0200 	mov.w	r2, #0
7000261e:	f04f 0300 	mov.w	r3, #0
70002622:	020b      	lsls	r3, r1, #8
70002624:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
70002628:	0202      	lsls	r2, r0, #8
7000262a:	6979      	ldr	r1, [r7, #20]
7000262c:	6849      	ldr	r1, [r1, #4]
7000262e:	0849      	lsrs	r1, r1, #1
70002630:	2000      	movs	r0, #0
70002632:	460c      	mov	r4, r1
70002634:	4605      	mov	r5, r0
70002636:	eb12 0804 	adds.w	r8, r2, r4
7000263a:	eb43 0905 	adc.w	r9, r3, r5
7000263e:	697b      	ldr	r3, [r7, #20]
70002640:	685b      	ldr	r3, [r3, #4]
70002642:	2200      	movs	r2, #0
70002644:	469a      	mov	sl, r3
70002646:	4693      	mov	fp, r2
70002648:	4652      	mov	r2, sl
7000264a:	465b      	mov	r3, fp
7000264c:	4640      	mov	r0, r8
7000264e:	4649      	mov	r1, r9
70002650:	f7fd fe4e 	bl	700002f0 <__aeabi_uldivmod>
70002654:	4602      	mov	r2, r0
70002656:	460b      	mov	r3, r1
70002658:	4613      	mov	r3, r2
7000265a:	623b      	str	r3, [r7, #32]
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
7000265c:	6a3b      	ldr	r3, [r7, #32]
7000265e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70002662:	d308      	bcc.n	70002676 <UART_SetConfig+0x416>
70002664:	6a3b      	ldr	r3, [r7, #32]
70002666:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
7000266a:	d204      	bcs.n	70002676 <UART_SetConfig+0x416>
        {
          huart->Instance->BRR = usartdiv;
7000266c:	697b      	ldr	r3, [r7, #20]
7000266e:	681b      	ldr	r3, [r3, #0]
70002670:	6a3a      	ldr	r2, [r7, #32]
70002672:	60da      	str	r2, [r3, #12]
70002674:	e16c      	b.n	70002950 <UART_SetConfig+0x6f0>
        }
        else
        {
          ret = HAL_ERROR;
70002676:	2301      	movs	r3, #1
70002678:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
7000267c:	e168      	b.n	70002950 <UART_SetConfig+0x6f0>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
7000267e:	697b      	ldr	r3, [r7, #20]
70002680:	69db      	ldr	r3, [r3, #28]
70002682:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
70002686:	f040 80bd 	bne.w	70002804 <UART_SetConfig+0x5a4>
  {
    switch (clocksource)
7000268a:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
7000268e:	2b20      	cmp	r3, #32
70002690:	dc48      	bgt.n	70002724 <UART_SetConfig+0x4c4>
70002692:	2b00      	cmp	r3, #0
70002694:	db73      	blt.n	7000277e <UART_SetConfig+0x51e>
70002696:	2b20      	cmp	r3, #32
70002698:	d871      	bhi.n	7000277e <UART_SetConfig+0x51e>
7000269a:	a201      	add	r2, pc, #4	@ (adr r2, 700026a0 <UART_SetConfig+0x440>)
7000269c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
700026a0:	7000272b 	.word	0x7000272b
700026a4:	70002733 	.word	0x70002733
700026a8:	7000277f 	.word	0x7000277f
700026ac:	7000277f 	.word	0x7000277f
700026b0:	7000273b 	.word	0x7000273b
700026b4:	7000277f 	.word	0x7000277f
700026b8:	7000277f 	.word	0x7000277f
700026bc:	7000277f 	.word	0x7000277f
700026c0:	70002743 	.word	0x70002743
700026c4:	7000277f 	.word	0x7000277f
700026c8:	7000277f 	.word	0x7000277f
700026cc:	7000277f 	.word	0x7000277f
700026d0:	7000277f 	.word	0x7000277f
700026d4:	7000277f 	.word	0x7000277f
700026d8:	7000277f 	.word	0x7000277f
700026dc:	7000277f 	.word	0x7000277f
700026e0:	7000274b 	.word	0x7000274b
700026e4:	7000277f 	.word	0x7000277f
700026e8:	7000277f 	.word	0x7000277f
700026ec:	7000277f 	.word	0x7000277f
700026f0:	7000277f 	.word	0x7000277f
700026f4:	7000277f 	.word	0x7000277f
700026f8:	7000277f 	.word	0x7000277f
700026fc:	7000277f 	.word	0x7000277f
70002700:	7000277f 	.word	0x7000277f
70002704:	7000277f 	.word	0x7000277f
70002708:	7000277f 	.word	0x7000277f
7000270c:	7000277f 	.word	0x7000277f
70002710:	7000277f 	.word	0x7000277f
70002714:	7000277f 	.word	0x7000277f
70002718:	7000277f 	.word	0x7000277f
7000271c:	7000277f 	.word	0x7000277f
70002720:	70002771 	.word	0x70002771
70002724:	2b40      	cmp	r3, #64	@ 0x40
70002726:	d026      	beq.n	70002776 <UART_SetConfig+0x516>
70002728:	e029      	b.n	7000277e <UART_SetConfig+0x51e>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
7000272a:	f7ff fbb3 	bl	70001e94 <HAL_RCC_GetPCLK1Freq>
7000272e:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70002730:	e02b      	b.n	7000278a <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
70002732:	f7ff fbcb 	bl	70001ecc <HAL_RCC_GetPCLK2Freq>
70002736:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70002738:	e027      	b.n	7000278a <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_PLL2Q:
        pclk = HAL_RCC_GetPLL2QFreq();
7000273a:	f7ff fbff 	bl	70001f3c <HAL_RCC_GetPLL2QFreq>
7000273e:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70002740:	e023      	b.n	7000278a <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_PLL3Q:
        pclk = HAL_RCC_GetPLL3QFreq();
70002742:	f7ff fc11 	bl	70001f68 <HAL_RCC_GetPLL3QFreq>
70002746:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70002748:	e01f      	b.n	7000278a <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
7000274a:	4b2d      	ldr	r3, [pc, #180]	@ (70002800 <UART_SetConfig+0x5a0>)
7000274c:	681b      	ldr	r3, [r3, #0]
7000274e:	f003 0320 	and.w	r3, r3, #32
70002752:	2b00      	cmp	r3, #0
70002754:	d009      	beq.n	7000276a <UART_SetConfig+0x50a>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
70002756:	4b2a      	ldr	r3, [pc, #168]	@ (70002800 <UART_SetConfig+0x5a0>)
70002758:	681b      	ldr	r3, [r3, #0]
7000275a:	08db      	lsrs	r3, r3, #3
7000275c:	f003 0303 	and.w	r3, r3, #3
70002760:	4a24      	ldr	r2, [pc, #144]	@ (700027f4 <UART_SetConfig+0x594>)
70002762:	fa22 f303 	lsr.w	r3, r2, r3
70002766:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
70002768:	e00f      	b.n	7000278a <UART_SetConfig+0x52a>
          pclk = (uint32_t) HSI_VALUE;
7000276a:	4b22      	ldr	r3, [pc, #136]	@ (700027f4 <UART_SetConfig+0x594>)
7000276c:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
7000276e:	e00c      	b.n	7000278a <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
70002770:	4b21      	ldr	r3, [pc, #132]	@ (700027f8 <UART_SetConfig+0x598>)
70002772:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
70002774:	e009      	b.n	7000278a <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
70002776:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
7000277a:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
7000277c:	e005      	b.n	7000278a <UART_SetConfig+0x52a>
      default:
        pclk = 0U;
7000277e:	2300      	movs	r3, #0
70002780:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = HAL_ERROR;
70002782:	2301      	movs	r3, #1
70002784:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
        break;
70002788:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
7000278a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
7000278c:	2b00      	cmp	r3, #0
7000278e:	f000 80df 	beq.w	70002950 <UART_SetConfig+0x6f0>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
70002792:	697b      	ldr	r3, [r7, #20]
70002794:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
70002796:	4a19      	ldr	r2, [pc, #100]	@ (700027fc <UART_SetConfig+0x59c>)
70002798:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
7000279c:	461a      	mov	r2, r3
7000279e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700027a0:	fbb3 f3f2 	udiv	r3, r3, r2
700027a4:	005a      	lsls	r2, r3, #1
700027a6:	697b      	ldr	r3, [r7, #20]
700027a8:	685b      	ldr	r3, [r3, #4]
700027aa:	085b      	lsrs	r3, r3, #1
700027ac:	441a      	add	r2, r3
700027ae:	697b      	ldr	r3, [r7, #20]
700027b0:	685b      	ldr	r3, [r3, #4]
700027b2:	fbb2 f3f3 	udiv	r3, r2, r3
700027b6:	623b      	str	r3, [r7, #32]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
700027b8:	6a3b      	ldr	r3, [r7, #32]
700027ba:	2b0f      	cmp	r3, #15
700027bc:	d916      	bls.n	700027ec <UART_SetConfig+0x58c>
700027be:	6a3b      	ldr	r3, [r7, #32]
700027c0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
700027c4:	d212      	bcs.n	700027ec <UART_SetConfig+0x58c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
700027c6:	6a3b      	ldr	r3, [r7, #32]
700027c8:	b29b      	uxth	r3, r3
700027ca:	f023 030f 	bic.w	r3, r3, #15
700027ce:	83fb      	strh	r3, [r7, #30]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
700027d0:	6a3b      	ldr	r3, [r7, #32]
700027d2:	085b      	lsrs	r3, r3, #1
700027d4:	b29b      	uxth	r3, r3
700027d6:	f003 0307 	and.w	r3, r3, #7
700027da:	b29a      	uxth	r2, r3
700027dc:	8bfb      	ldrh	r3, [r7, #30]
700027de:	4313      	orrs	r3, r2
700027e0:	83fb      	strh	r3, [r7, #30]
        huart->Instance->BRR = brrtemp;
700027e2:	697b      	ldr	r3, [r7, #20]
700027e4:	681b      	ldr	r3, [r3, #0]
700027e6:	8bfa      	ldrh	r2, [r7, #30]
700027e8:	60da      	str	r2, [r3, #12]
700027ea:	e0b1      	b.n	70002950 <UART_SetConfig+0x6f0>
      }
      else
      {
        ret = HAL_ERROR;
700027ec:	2301      	movs	r3, #1
700027ee:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
700027f2:	e0ad      	b.n	70002950 <UART_SetConfig+0x6f0>
700027f4:	03d09000 	.word	0x03d09000
700027f8:	003d0900 	.word	0x003d0900
700027fc:	70002e34 	.word	0x70002e34
70002800:	58024400 	.word	0x58024400
      }
    }
  }
  else
  {
    switch (clocksource)
70002804:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
70002808:	2b20      	cmp	r3, #32
7000280a:	dc49      	bgt.n	700028a0 <UART_SetConfig+0x640>
7000280c:	2b00      	cmp	r3, #0
7000280e:	db74      	blt.n	700028fa <UART_SetConfig+0x69a>
70002810:	2b20      	cmp	r3, #32
70002812:	d872      	bhi.n	700028fa <UART_SetConfig+0x69a>
70002814:	a201      	add	r2, pc, #4	@ (adr r2, 7000281c <UART_SetConfig+0x5bc>)
70002816:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
7000281a:	bf00      	nop
7000281c:	700028a7 	.word	0x700028a7
70002820:	700028af 	.word	0x700028af
70002824:	700028fb 	.word	0x700028fb
70002828:	700028fb 	.word	0x700028fb
7000282c:	700028b7 	.word	0x700028b7
70002830:	700028fb 	.word	0x700028fb
70002834:	700028fb 	.word	0x700028fb
70002838:	700028fb 	.word	0x700028fb
7000283c:	700028bf 	.word	0x700028bf
70002840:	700028fb 	.word	0x700028fb
70002844:	700028fb 	.word	0x700028fb
70002848:	700028fb 	.word	0x700028fb
7000284c:	700028fb 	.word	0x700028fb
70002850:	700028fb 	.word	0x700028fb
70002854:	700028fb 	.word	0x700028fb
70002858:	700028fb 	.word	0x700028fb
7000285c:	700028c7 	.word	0x700028c7
70002860:	700028fb 	.word	0x700028fb
70002864:	700028fb 	.word	0x700028fb
70002868:	700028fb 	.word	0x700028fb
7000286c:	700028fb 	.word	0x700028fb
70002870:	700028fb 	.word	0x700028fb
70002874:	700028fb 	.word	0x700028fb
70002878:	700028fb 	.word	0x700028fb
7000287c:	700028fb 	.word	0x700028fb
70002880:	700028fb 	.word	0x700028fb
70002884:	700028fb 	.word	0x700028fb
70002888:	700028fb 	.word	0x700028fb
7000288c:	700028fb 	.word	0x700028fb
70002890:	700028fb 	.word	0x700028fb
70002894:	700028fb 	.word	0x700028fb
70002898:	700028fb 	.word	0x700028fb
7000289c:	700028ed 	.word	0x700028ed
700028a0:	2b40      	cmp	r3, #64	@ 0x40
700028a2:	d026      	beq.n	700028f2 <UART_SetConfig+0x692>
700028a4:	e029      	b.n	700028fa <UART_SetConfig+0x69a>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
700028a6:	f7ff faf5 	bl	70001e94 <HAL_RCC_GetPCLK1Freq>
700028aa:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700028ac:	e02b      	b.n	70002906 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
700028ae:	f7ff fb0d 	bl	70001ecc <HAL_RCC_GetPCLK2Freq>
700028b2:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700028b4:	e027      	b.n	70002906 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_PLL2Q:
        pclk = HAL_RCC_GetPLL2QFreq();
700028b6:	f7ff fb41 	bl	70001f3c <HAL_RCC_GetPLL2QFreq>
700028ba:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700028bc:	e023      	b.n	70002906 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_PLL3Q:
        pclk = HAL_RCC_GetPLL3QFreq();
700028be:	f7ff fb53 	bl	70001f68 <HAL_RCC_GetPLL3QFreq>
700028c2:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700028c4:	e01f      	b.n	70002906 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
700028c6:	4b2d      	ldr	r3, [pc, #180]	@ (7000297c <UART_SetConfig+0x71c>)
700028c8:	681b      	ldr	r3, [r3, #0]
700028ca:	f003 0320 	and.w	r3, r3, #32
700028ce:	2b00      	cmp	r3, #0
700028d0:	d009      	beq.n	700028e6 <UART_SetConfig+0x686>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
700028d2:	4b2a      	ldr	r3, [pc, #168]	@ (7000297c <UART_SetConfig+0x71c>)
700028d4:	681b      	ldr	r3, [r3, #0]
700028d6:	08db      	lsrs	r3, r3, #3
700028d8:	f003 0303 	and.w	r3, r3, #3
700028dc:	4a28      	ldr	r2, [pc, #160]	@ (70002980 <UART_SetConfig+0x720>)
700028de:	fa22 f303 	lsr.w	r3, r2, r3
700028e2:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
700028e4:	e00f      	b.n	70002906 <UART_SetConfig+0x6a6>
          pclk = (uint32_t) HSI_VALUE;
700028e6:	4b26      	ldr	r3, [pc, #152]	@ (70002980 <UART_SetConfig+0x720>)
700028e8:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
700028ea:	e00c      	b.n	70002906 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
700028ec:	4b25      	ldr	r3, [pc, #148]	@ (70002984 <UART_SetConfig+0x724>)
700028ee:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
700028f0:	e009      	b.n	70002906 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
700028f2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
700028f6:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
700028f8:	e005      	b.n	70002906 <UART_SetConfig+0x6a6>
      default:
        pclk = 0U;
700028fa:	2300      	movs	r3, #0
700028fc:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = HAL_ERROR;
700028fe:	2301      	movs	r3, #1
70002900:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
        break;
70002904:	bf00      	nop
    }

    if (pclk != 0U)
70002906:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
70002908:	2b00      	cmp	r3, #0
7000290a:	d021      	beq.n	70002950 <UART_SetConfig+0x6f0>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
7000290c:	697b      	ldr	r3, [r7, #20]
7000290e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
70002910:	4a1d      	ldr	r2, [pc, #116]	@ (70002988 <UART_SetConfig+0x728>)
70002912:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
70002916:	461a      	mov	r2, r3
70002918:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
7000291a:	fbb3 f2f2 	udiv	r2, r3, r2
7000291e:	697b      	ldr	r3, [r7, #20]
70002920:	685b      	ldr	r3, [r3, #4]
70002922:	085b      	lsrs	r3, r3, #1
70002924:	441a      	add	r2, r3
70002926:	697b      	ldr	r3, [r7, #20]
70002928:	685b      	ldr	r3, [r3, #4]
7000292a:	fbb2 f3f3 	udiv	r3, r2, r3
7000292e:	623b      	str	r3, [r7, #32]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
70002930:	6a3b      	ldr	r3, [r7, #32]
70002932:	2b0f      	cmp	r3, #15
70002934:	d909      	bls.n	7000294a <UART_SetConfig+0x6ea>
70002936:	6a3b      	ldr	r3, [r7, #32]
70002938:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
7000293c:	d205      	bcs.n	7000294a <UART_SetConfig+0x6ea>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
7000293e:	6a3b      	ldr	r3, [r7, #32]
70002940:	b29a      	uxth	r2, r3
70002942:	697b      	ldr	r3, [r7, #20]
70002944:	681b      	ldr	r3, [r3, #0]
70002946:	60da      	str	r2, [r3, #12]
70002948:	e002      	b.n	70002950 <UART_SetConfig+0x6f0>
      }
      else
      {
        ret = HAL_ERROR;
7000294a:	2301      	movs	r3, #1
7000294c:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
70002950:	697b      	ldr	r3, [r7, #20]
70002952:	2201      	movs	r2, #1
70002954:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
70002958:	697b      	ldr	r3, [r7, #20]
7000295a:	2201      	movs	r2, #1
7000295c:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
70002960:	697b      	ldr	r3, [r7, #20]
70002962:	2200      	movs	r2, #0
70002964:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
70002966:	697b      	ldr	r3, [r7, #20]
70002968:	2200      	movs	r2, #0
7000296a:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
7000296c:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
}
70002970:	4618      	mov	r0, r3
70002972:	3730      	adds	r7, #48	@ 0x30
70002974:	46bd      	mov	sp, r7
70002976:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
7000297a:	bf00      	nop
7000297c:	58024400 	.word	0x58024400
70002980:	03d09000 	.word	0x03d09000
70002984:	003d0900 	.word	0x003d0900
70002988:	70002e34 	.word	0x70002e34

7000298c <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
7000298c:	b480      	push	{r7}
7000298e:	b083      	sub	sp, #12
70002990:	af00      	add	r7, sp, #0
70002992:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
70002994:	687b      	ldr	r3, [r7, #4]
70002996:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002998:	f003 0308 	and.w	r3, r3, #8
7000299c:	2b00      	cmp	r3, #0
7000299e:	d00a      	beq.n	700029b6 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
700029a0:	687b      	ldr	r3, [r7, #4]
700029a2:	681b      	ldr	r3, [r3, #0]
700029a4:	685b      	ldr	r3, [r3, #4]
700029a6:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
700029aa:	687b      	ldr	r3, [r7, #4]
700029ac:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
700029ae:	687b      	ldr	r3, [r7, #4]
700029b0:	681b      	ldr	r3, [r3, #0]
700029b2:	430a      	orrs	r2, r1
700029b4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
700029b6:	687b      	ldr	r3, [r7, #4]
700029b8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700029ba:	f003 0301 	and.w	r3, r3, #1
700029be:	2b00      	cmp	r3, #0
700029c0:	d00a      	beq.n	700029d8 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
700029c2:	687b      	ldr	r3, [r7, #4]
700029c4:	681b      	ldr	r3, [r3, #0]
700029c6:	685b      	ldr	r3, [r3, #4]
700029c8:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
700029cc:	687b      	ldr	r3, [r7, #4]
700029ce:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
700029d0:	687b      	ldr	r3, [r7, #4]
700029d2:	681b      	ldr	r3, [r3, #0]
700029d4:	430a      	orrs	r2, r1
700029d6:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
700029d8:	687b      	ldr	r3, [r7, #4]
700029da:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700029dc:	f003 0302 	and.w	r3, r3, #2
700029e0:	2b00      	cmp	r3, #0
700029e2:	d00a      	beq.n	700029fa <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
700029e4:	687b      	ldr	r3, [r7, #4]
700029e6:	681b      	ldr	r3, [r3, #0]
700029e8:	685b      	ldr	r3, [r3, #4]
700029ea:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
700029ee:	687b      	ldr	r3, [r7, #4]
700029f0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
700029f2:	687b      	ldr	r3, [r7, #4]
700029f4:	681b      	ldr	r3, [r3, #0]
700029f6:	430a      	orrs	r2, r1
700029f8:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
700029fa:	687b      	ldr	r3, [r7, #4]
700029fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700029fe:	f003 0304 	and.w	r3, r3, #4
70002a02:	2b00      	cmp	r3, #0
70002a04:	d00a      	beq.n	70002a1c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
70002a06:	687b      	ldr	r3, [r7, #4]
70002a08:	681b      	ldr	r3, [r3, #0]
70002a0a:	685b      	ldr	r3, [r3, #4]
70002a0c:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
70002a10:	687b      	ldr	r3, [r7, #4]
70002a12:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
70002a14:	687b      	ldr	r3, [r7, #4]
70002a16:	681b      	ldr	r3, [r3, #0]
70002a18:	430a      	orrs	r2, r1
70002a1a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
70002a1c:	687b      	ldr	r3, [r7, #4]
70002a1e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002a20:	f003 0310 	and.w	r3, r3, #16
70002a24:	2b00      	cmp	r3, #0
70002a26:	d00a      	beq.n	70002a3e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
70002a28:	687b      	ldr	r3, [r7, #4]
70002a2a:	681b      	ldr	r3, [r3, #0]
70002a2c:	689b      	ldr	r3, [r3, #8]
70002a2e:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
70002a32:	687b      	ldr	r3, [r7, #4]
70002a34:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
70002a36:	687b      	ldr	r3, [r7, #4]
70002a38:	681b      	ldr	r3, [r3, #0]
70002a3a:	430a      	orrs	r2, r1
70002a3c:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
70002a3e:	687b      	ldr	r3, [r7, #4]
70002a40:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002a42:	f003 0320 	and.w	r3, r3, #32
70002a46:	2b00      	cmp	r3, #0
70002a48:	d00a      	beq.n	70002a60 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
70002a4a:	687b      	ldr	r3, [r7, #4]
70002a4c:	681b      	ldr	r3, [r3, #0]
70002a4e:	689b      	ldr	r3, [r3, #8]
70002a50:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
70002a54:	687b      	ldr	r3, [r7, #4]
70002a56:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
70002a58:	687b      	ldr	r3, [r7, #4]
70002a5a:	681b      	ldr	r3, [r3, #0]
70002a5c:	430a      	orrs	r2, r1
70002a5e:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
70002a60:	687b      	ldr	r3, [r7, #4]
70002a62:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002a64:	f003 0340 	and.w	r3, r3, #64	@ 0x40
70002a68:	2b00      	cmp	r3, #0
70002a6a:	d01a      	beq.n	70002aa2 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
70002a6c:	687b      	ldr	r3, [r7, #4]
70002a6e:	681b      	ldr	r3, [r3, #0]
70002a70:	685b      	ldr	r3, [r3, #4]
70002a72:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
70002a76:	687b      	ldr	r3, [r7, #4]
70002a78:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
70002a7a:	687b      	ldr	r3, [r7, #4]
70002a7c:	681b      	ldr	r3, [r3, #0]
70002a7e:	430a      	orrs	r2, r1
70002a80:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
70002a82:	687b      	ldr	r3, [r7, #4]
70002a84:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
70002a86:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
70002a8a:	d10a      	bne.n	70002aa2 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
70002a8c:	687b      	ldr	r3, [r7, #4]
70002a8e:	681b      	ldr	r3, [r3, #0]
70002a90:	685b      	ldr	r3, [r3, #4]
70002a92:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
70002a96:	687b      	ldr	r3, [r7, #4]
70002a98:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
70002a9a:	687b      	ldr	r3, [r7, #4]
70002a9c:	681b      	ldr	r3, [r3, #0]
70002a9e:	430a      	orrs	r2, r1
70002aa0:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
70002aa2:	687b      	ldr	r3, [r7, #4]
70002aa4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002aa6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
70002aaa:	2b00      	cmp	r3, #0
70002aac:	d00a      	beq.n	70002ac4 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
70002aae:	687b      	ldr	r3, [r7, #4]
70002ab0:	681b      	ldr	r3, [r3, #0]
70002ab2:	685b      	ldr	r3, [r3, #4]
70002ab4:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
70002ab8:	687b      	ldr	r3, [r7, #4]
70002aba:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
70002abc:	687b      	ldr	r3, [r7, #4]
70002abe:	681b      	ldr	r3, [r3, #0]
70002ac0:	430a      	orrs	r2, r1
70002ac2:	605a      	str	r2, [r3, #4]
  }
}
70002ac4:	bf00      	nop
70002ac6:	370c      	adds	r7, #12
70002ac8:	46bd      	mov	sp, r7
70002aca:	f85d 7b04 	ldr.w	r7, [sp], #4
70002ace:	4770      	bx	lr

70002ad0 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
70002ad0:	b580      	push	{r7, lr}
70002ad2:	b098      	sub	sp, #96	@ 0x60
70002ad4:	af02      	add	r7, sp, #8
70002ad6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
70002ad8:	687b      	ldr	r3, [r7, #4]
70002ada:	2200      	movs	r2, #0
70002adc:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
70002ae0:	f7fe fd24 	bl	7000152c <HAL_GetTick>
70002ae4:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
70002ae6:	687b      	ldr	r3, [r7, #4]
70002ae8:	681b      	ldr	r3, [r3, #0]
70002aea:	681b      	ldr	r3, [r3, #0]
70002aec:	f003 0308 	and.w	r3, r3, #8
70002af0:	2b08      	cmp	r3, #8
70002af2:	d12f      	bne.n	70002b54 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
70002af4:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
70002af8:	9300      	str	r3, [sp, #0]
70002afa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
70002afc:	2200      	movs	r2, #0
70002afe:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
70002b02:	6878      	ldr	r0, [r7, #4]
70002b04:	f000 f88e 	bl	70002c24 <UART_WaitOnFlagUntilTimeout>
70002b08:	4603      	mov	r3, r0
70002b0a:	2b00      	cmp	r3, #0
70002b0c:	d022      	beq.n	70002b54 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
70002b0e:	687b      	ldr	r3, [r7, #4]
70002b10:	681b      	ldr	r3, [r3, #0]
70002b12:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70002b14:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
70002b16:	e853 3f00 	ldrex	r3, [r3]
70002b1a:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
70002b1c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
70002b1e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
70002b22:	653b      	str	r3, [r7, #80]	@ 0x50
70002b24:	687b      	ldr	r3, [r7, #4]
70002b26:	681b      	ldr	r3, [r3, #0]
70002b28:	461a      	mov	r2, r3
70002b2a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
70002b2c:	647b      	str	r3, [r7, #68]	@ 0x44
70002b2e:	643a      	str	r2, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
70002b30:	6c39      	ldr	r1, [r7, #64]	@ 0x40
70002b32:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
70002b34:	e841 2300 	strex	r3, r2, [r1]
70002b38:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
70002b3a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
70002b3c:	2b00      	cmp	r3, #0
70002b3e:	d1e6      	bne.n	70002b0e <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
70002b40:	687b      	ldr	r3, [r7, #4]
70002b42:	2220      	movs	r2, #32
70002b44:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
70002b48:	687b      	ldr	r3, [r7, #4]
70002b4a:	2200      	movs	r2, #0
70002b4c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
70002b50:	2303      	movs	r3, #3
70002b52:	e063      	b.n	70002c1c <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
70002b54:	687b      	ldr	r3, [r7, #4]
70002b56:	681b      	ldr	r3, [r3, #0]
70002b58:	681b      	ldr	r3, [r3, #0]
70002b5a:	f003 0304 	and.w	r3, r3, #4
70002b5e:	2b04      	cmp	r3, #4
70002b60:	d149      	bne.n	70002bf6 <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
70002b62:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
70002b66:	9300      	str	r3, [sp, #0]
70002b68:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
70002b6a:	2200      	movs	r2, #0
70002b6c:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
70002b70:	6878      	ldr	r0, [r7, #4]
70002b72:	f000 f857 	bl	70002c24 <UART_WaitOnFlagUntilTimeout>
70002b76:	4603      	mov	r3, r0
70002b78:	2b00      	cmp	r3, #0
70002b7a:	d03c      	beq.n	70002bf6 <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
70002b7c:	687b      	ldr	r3, [r7, #4]
70002b7e:	681b      	ldr	r3, [r3, #0]
70002b80:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70002b82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
70002b84:	e853 3f00 	ldrex	r3, [r3]
70002b88:	623b      	str	r3, [r7, #32]
   return(result);
70002b8a:	6a3b      	ldr	r3, [r7, #32]
70002b8c:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
70002b90:	64fb      	str	r3, [r7, #76]	@ 0x4c
70002b92:	687b      	ldr	r3, [r7, #4]
70002b94:	681b      	ldr	r3, [r3, #0]
70002b96:	461a      	mov	r2, r3
70002b98:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
70002b9a:	633b      	str	r3, [r7, #48]	@ 0x30
70002b9c:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
70002b9e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
70002ba0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
70002ba2:	e841 2300 	strex	r3, r2, [r1]
70002ba6:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
70002ba8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
70002baa:	2b00      	cmp	r3, #0
70002bac:	d1e6      	bne.n	70002b7c <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
70002bae:	687b      	ldr	r3, [r7, #4]
70002bb0:	681b      	ldr	r3, [r3, #0]
70002bb2:	3308      	adds	r3, #8
70002bb4:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70002bb6:	693b      	ldr	r3, [r7, #16]
70002bb8:	e853 3f00 	ldrex	r3, [r3]
70002bbc:	60fb      	str	r3, [r7, #12]
   return(result);
70002bbe:	68fb      	ldr	r3, [r7, #12]
70002bc0:	f023 0301 	bic.w	r3, r3, #1
70002bc4:	64bb      	str	r3, [r7, #72]	@ 0x48
70002bc6:	687b      	ldr	r3, [r7, #4]
70002bc8:	681b      	ldr	r3, [r3, #0]
70002bca:	3308      	adds	r3, #8
70002bcc:	6cba      	ldr	r2, [r7, #72]	@ 0x48
70002bce:	61fa      	str	r2, [r7, #28]
70002bd0:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
70002bd2:	69b9      	ldr	r1, [r7, #24]
70002bd4:	69fa      	ldr	r2, [r7, #28]
70002bd6:	e841 2300 	strex	r3, r2, [r1]
70002bda:	617b      	str	r3, [r7, #20]
   return(result);
70002bdc:	697b      	ldr	r3, [r7, #20]
70002bde:	2b00      	cmp	r3, #0
70002be0:	d1e5      	bne.n	70002bae <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
70002be2:	687b      	ldr	r3, [r7, #4]
70002be4:	2220      	movs	r2, #32
70002be6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
70002bea:	687b      	ldr	r3, [r7, #4]
70002bec:	2200      	movs	r2, #0
70002bee:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
70002bf2:	2303      	movs	r3, #3
70002bf4:	e012      	b.n	70002c1c <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
70002bf6:	687b      	ldr	r3, [r7, #4]
70002bf8:	2220      	movs	r2, #32
70002bfa:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
70002bfe:	687b      	ldr	r3, [r7, #4]
70002c00:	2220      	movs	r2, #32
70002c02:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
70002c06:	687b      	ldr	r3, [r7, #4]
70002c08:	2200      	movs	r2, #0
70002c0a:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
70002c0c:	687b      	ldr	r3, [r7, #4]
70002c0e:	2200      	movs	r2, #0
70002c10:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
70002c12:	687b      	ldr	r3, [r7, #4]
70002c14:	2200      	movs	r2, #0
70002c16:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
70002c1a:	2300      	movs	r3, #0
}
70002c1c:	4618      	mov	r0, r3
70002c1e:	3758      	adds	r7, #88	@ 0x58
70002c20:	46bd      	mov	sp, r7
70002c22:	bd80      	pop	{r7, pc}

70002c24 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
70002c24:	b580      	push	{r7, lr}
70002c26:	b084      	sub	sp, #16
70002c28:	af00      	add	r7, sp, #0
70002c2a:	60f8      	str	r0, [r7, #12]
70002c2c:	60b9      	str	r1, [r7, #8]
70002c2e:	603b      	str	r3, [r7, #0]
70002c30:	4613      	mov	r3, r2
70002c32:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
70002c34:	e04f      	b.n	70002cd6 <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
70002c36:	69bb      	ldr	r3, [r7, #24]
70002c38:	f1b3 3fff 	cmp.w	r3, #4294967295
70002c3c:	d04b      	beq.n	70002cd6 <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
70002c3e:	f7fe fc75 	bl	7000152c <HAL_GetTick>
70002c42:	4602      	mov	r2, r0
70002c44:	683b      	ldr	r3, [r7, #0]
70002c46:	1ad3      	subs	r3, r2, r3
70002c48:	69ba      	ldr	r2, [r7, #24]
70002c4a:	429a      	cmp	r2, r3
70002c4c:	d302      	bcc.n	70002c54 <UART_WaitOnFlagUntilTimeout+0x30>
70002c4e:	69bb      	ldr	r3, [r7, #24]
70002c50:	2b00      	cmp	r3, #0
70002c52:	d101      	bne.n	70002c58 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
70002c54:	2303      	movs	r3, #3
70002c56:	e04e      	b.n	70002cf6 <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
70002c58:	68fb      	ldr	r3, [r7, #12]
70002c5a:	681b      	ldr	r3, [r3, #0]
70002c5c:	681b      	ldr	r3, [r3, #0]
70002c5e:	f003 0304 	and.w	r3, r3, #4
70002c62:	2b00      	cmp	r3, #0
70002c64:	d037      	beq.n	70002cd6 <UART_WaitOnFlagUntilTimeout+0xb2>
70002c66:	68bb      	ldr	r3, [r7, #8]
70002c68:	2b80      	cmp	r3, #128	@ 0x80
70002c6a:	d034      	beq.n	70002cd6 <UART_WaitOnFlagUntilTimeout+0xb2>
70002c6c:	68bb      	ldr	r3, [r7, #8]
70002c6e:	2b40      	cmp	r3, #64	@ 0x40
70002c70:	d031      	beq.n	70002cd6 <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
70002c72:	68fb      	ldr	r3, [r7, #12]
70002c74:	681b      	ldr	r3, [r3, #0]
70002c76:	69db      	ldr	r3, [r3, #28]
70002c78:	f003 0308 	and.w	r3, r3, #8
70002c7c:	2b08      	cmp	r3, #8
70002c7e:	d110      	bne.n	70002ca2 <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
70002c80:	68fb      	ldr	r3, [r7, #12]
70002c82:	681b      	ldr	r3, [r3, #0]
70002c84:	2208      	movs	r2, #8
70002c86:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
70002c88:	68f8      	ldr	r0, [r7, #12]
70002c8a:	f000 f839 	bl	70002d00 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
70002c8e:	68fb      	ldr	r3, [r7, #12]
70002c90:	2208      	movs	r2, #8
70002c92:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
70002c96:	68fb      	ldr	r3, [r7, #12]
70002c98:	2200      	movs	r2, #0
70002c9a:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
70002c9e:	2301      	movs	r3, #1
70002ca0:	e029      	b.n	70002cf6 <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
70002ca2:	68fb      	ldr	r3, [r7, #12]
70002ca4:	681b      	ldr	r3, [r3, #0]
70002ca6:	69db      	ldr	r3, [r3, #28]
70002ca8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
70002cac:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
70002cb0:	d111      	bne.n	70002cd6 <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
70002cb2:	68fb      	ldr	r3, [r7, #12]
70002cb4:	681b      	ldr	r3, [r3, #0]
70002cb6:	f44f 6200 	mov.w	r2, #2048	@ 0x800
70002cba:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
70002cbc:	68f8      	ldr	r0, [r7, #12]
70002cbe:	f000 f81f 	bl	70002d00 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
70002cc2:	68fb      	ldr	r3, [r7, #12]
70002cc4:	2220      	movs	r2, #32
70002cc6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
70002cca:	68fb      	ldr	r3, [r7, #12]
70002ccc:	2200      	movs	r2, #0
70002cce:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
70002cd2:	2303      	movs	r3, #3
70002cd4:	e00f      	b.n	70002cf6 <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
70002cd6:	68fb      	ldr	r3, [r7, #12]
70002cd8:	681b      	ldr	r3, [r3, #0]
70002cda:	69da      	ldr	r2, [r3, #28]
70002cdc:	68bb      	ldr	r3, [r7, #8]
70002cde:	4013      	ands	r3, r2
70002ce0:	68ba      	ldr	r2, [r7, #8]
70002ce2:	429a      	cmp	r2, r3
70002ce4:	bf0c      	ite	eq
70002ce6:	2301      	moveq	r3, #1
70002ce8:	2300      	movne	r3, #0
70002cea:	b2db      	uxtb	r3, r3
70002cec:	461a      	mov	r2, r3
70002cee:	79fb      	ldrb	r3, [r7, #7]
70002cf0:	429a      	cmp	r2, r3
70002cf2:	d0a0      	beq.n	70002c36 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
70002cf4:	2300      	movs	r3, #0
}
70002cf6:	4618      	mov	r0, r3
70002cf8:	3710      	adds	r7, #16
70002cfa:	46bd      	mov	sp, r7
70002cfc:	bd80      	pop	{r7, pc}
	...

70002d00 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
70002d00:	b480      	push	{r7}
70002d02:	b095      	sub	sp, #84	@ 0x54
70002d04:	af00      	add	r7, sp, #0
70002d06:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
70002d08:	687b      	ldr	r3, [r7, #4]
70002d0a:	681b      	ldr	r3, [r3, #0]
70002d0c:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70002d0e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
70002d10:	e853 3f00 	ldrex	r3, [r3]
70002d14:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
70002d16:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
70002d18:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
70002d1c:	64fb      	str	r3, [r7, #76]	@ 0x4c
70002d1e:	687b      	ldr	r3, [r7, #4]
70002d20:	681b      	ldr	r3, [r3, #0]
70002d22:	461a      	mov	r2, r3
70002d24:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
70002d26:	643b      	str	r3, [r7, #64]	@ 0x40
70002d28:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
70002d2a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
70002d2c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
70002d2e:	e841 2300 	strex	r3, r2, [r1]
70002d32:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
70002d34:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
70002d36:	2b00      	cmp	r3, #0
70002d38:	d1e6      	bne.n	70002d08 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
70002d3a:	687b      	ldr	r3, [r7, #4]
70002d3c:	681b      	ldr	r3, [r3, #0]
70002d3e:	3308      	adds	r3, #8
70002d40:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70002d42:	6a3b      	ldr	r3, [r7, #32]
70002d44:	e853 3f00 	ldrex	r3, [r3]
70002d48:	61fb      	str	r3, [r7, #28]
   return(result);
70002d4a:	69fa      	ldr	r2, [r7, #28]
70002d4c:	4b1e      	ldr	r3, [pc, #120]	@ (70002dc8 <UART_EndRxTransfer+0xc8>)
70002d4e:	4013      	ands	r3, r2
70002d50:	64bb      	str	r3, [r7, #72]	@ 0x48
70002d52:	687b      	ldr	r3, [r7, #4]
70002d54:	681b      	ldr	r3, [r3, #0]
70002d56:	3308      	adds	r3, #8
70002d58:	6cba      	ldr	r2, [r7, #72]	@ 0x48
70002d5a:	62fa      	str	r2, [r7, #44]	@ 0x2c
70002d5c:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
70002d5e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
70002d60:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
70002d62:	e841 2300 	strex	r3, r2, [r1]
70002d66:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
70002d68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
70002d6a:	2b00      	cmp	r3, #0
70002d6c:	d1e5      	bne.n	70002d3a <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
70002d6e:	687b      	ldr	r3, [r7, #4]
70002d70:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
70002d72:	2b01      	cmp	r3, #1
70002d74:	d118      	bne.n	70002da8 <UART_EndRxTransfer+0xa8>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
70002d76:	687b      	ldr	r3, [r7, #4]
70002d78:	681b      	ldr	r3, [r3, #0]
70002d7a:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70002d7c:	68fb      	ldr	r3, [r7, #12]
70002d7e:	e853 3f00 	ldrex	r3, [r3]
70002d82:	60bb      	str	r3, [r7, #8]
   return(result);
70002d84:	68bb      	ldr	r3, [r7, #8]
70002d86:	f023 0310 	bic.w	r3, r3, #16
70002d8a:	647b      	str	r3, [r7, #68]	@ 0x44
70002d8c:	687b      	ldr	r3, [r7, #4]
70002d8e:	681b      	ldr	r3, [r3, #0]
70002d90:	461a      	mov	r2, r3
70002d92:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
70002d94:	61bb      	str	r3, [r7, #24]
70002d96:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
70002d98:	6979      	ldr	r1, [r7, #20]
70002d9a:	69ba      	ldr	r2, [r7, #24]
70002d9c:	e841 2300 	strex	r3, r2, [r1]
70002da0:	613b      	str	r3, [r7, #16]
   return(result);
70002da2:	693b      	ldr	r3, [r7, #16]
70002da4:	2b00      	cmp	r3, #0
70002da6:	d1e6      	bne.n	70002d76 <UART_EndRxTransfer+0x76>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
70002da8:	687b      	ldr	r3, [r7, #4]
70002daa:	2220      	movs	r2, #32
70002dac:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
70002db0:	687b      	ldr	r3, [r7, #4]
70002db2:	2200      	movs	r2, #0
70002db4:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
70002db6:	687b      	ldr	r3, [r7, #4]
70002db8:	2200      	movs	r2, #0
70002dba:	675a      	str	r2, [r3, #116]	@ 0x74
}
70002dbc:	bf00      	nop
70002dbe:	3754      	adds	r7, #84	@ 0x54
70002dc0:	46bd      	mov	sp, r7
70002dc2:	f85d 7b04 	ldr.w	r7, [sp], #4
70002dc6:	4770      	bx	lr
70002dc8:	effffffe 	.word	0xeffffffe

70002dcc <__libc_init_array>:
70002dcc:	b570      	push	{r4, r5, r6, lr}
70002dce:	4d0d      	ldr	r5, [pc, #52]	@ (70002e04 <__libc_init_array+0x38>)
70002dd0:	4c0d      	ldr	r4, [pc, #52]	@ (70002e08 <__libc_init_array+0x3c>)
70002dd2:	1b64      	subs	r4, r4, r5
70002dd4:	10a4      	asrs	r4, r4, #2
70002dd6:	2600      	movs	r6, #0
70002dd8:	42a6      	cmp	r6, r4
70002dda:	d109      	bne.n	70002df0 <__libc_init_array+0x24>
70002ddc:	4d0b      	ldr	r5, [pc, #44]	@ (70002e0c <__libc_init_array+0x40>)
70002dde:	4c0c      	ldr	r4, [pc, #48]	@ (70002e10 <__libc_init_array+0x44>)
70002de0:	f000 f818 	bl	70002e14 <_init>
70002de4:	1b64      	subs	r4, r4, r5
70002de6:	10a4      	asrs	r4, r4, #2
70002de8:	2600      	movs	r6, #0
70002dea:	42a6      	cmp	r6, r4
70002dec:	d105      	bne.n	70002dfa <__libc_init_array+0x2e>
70002dee:	bd70      	pop	{r4, r5, r6, pc}
70002df0:	f855 3b04 	ldr.w	r3, [r5], #4
70002df4:	4798      	blx	r3
70002df6:	3601      	adds	r6, #1
70002df8:	e7ee      	b.n	70002dd8 <__libc_init_array+0xc>
70002dfa:	f855 3b04 	ldr.w	r3, [r5], #4
70002dfe:	4798      	blx	r3
70002e00:	3601      	adds	r6, #1
70002e02:	e7f2      	b.n	70002dea <__libc_init_array+0x1e>
70002e04:	70002e54 	.word	0x70002e54
70002e08:	70002e54 	.word	0x70002e54
70002e0c:	70002e54 	.word	0x70002e54
70002e10:	70002e58 	.word	0x70002e58

70002e14 <_init>:
70002e14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
70002e16:	bf00      	nop
70002e18:	bcf8      	pop	{r3, r4, r5, r6, r7}
70002e1a:	bc08      	pop	{r3}
70002e1c:	469e      	mov	lr, r3
70002e1e:	4770      	bx	lr

70002e20 <_fini>:
70002e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
70002e22:	bf00      	nop
70002e24:	bcf8      	pop	{r3, r4, r5, r6, r7}
70002e26:	bc08      	pop	{r3}
70002e28:	469e      	mov	lr, r3
70002e2a:	4770      	bx	lr
